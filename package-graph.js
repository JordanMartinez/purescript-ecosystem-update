// Generated by purs bundle 0.14.7
var PS = {};
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Alt"] = $PS["Control.Alt"] || {};
  var exports = $PS["Control.Alt"];
  var alt = function (dict) {
      return dict.alt;
  };
  exports["alt"] = alt;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var l = fs.length;
      var k = xs.length;
      var result = new Array(l*k);
      var n = 0;
      for (var i = 0; i < l; i++) {
        var f = fs[i];
        for (var j = 0; j < k; j++) {
          result[n++] = f(xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];                    
  var on = function (f) {
      return function (g) {
          return function (x) {
              return function (y) {
                  return f(g(x))(g(y));
              };
          };
      };
  };
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  var applyFlipped = function (x) {
      return function (f) {
          return f(x);
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
  exports["applyFlipped"] = applyFlipped;
  exports["on"] = on;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var semigroupoidFn = {
      compose: function (f) {
          return function (g) {
              return function (x) {
                  return f(g(x));
              };
          };
      }
  };
  var compose = function (dict) {
      return dict.compose;
  };
  var composeFlipped = function (dictSemigroupoid) {
      return function (f) {
          return function (g) {
              return compose(dictSemigroupoid)(g)(f);
          };
      };
  };
  exports["compose"] = compose;
  exports["composeFlipped"] = composeFlipped;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Data_Function = $PS["Data.Function"];
  var Data_Unit = $PS["Data.Unit"];                  
  var map = function (dict) {
      return dict.map;
  };
  var mapFlipped = function (dictFunctor) {
      return function (fa) {
          return function (f) {
              return map(dictFunctor)(f)(fa);
          };
      };
  };
  var $$void = function (dictFunctor) {
      return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };
  var voidLeft = function (dictFunctor) {
      return function (f) {
          return function (x) {
              return map(dictFunctor)(Data_Function["const"](x))(f);
          };
      };
  };
  var voidRight = function (dictFunctor) {
      return function (x) {
          return map(dictFunctor)(Data_Function["const"](x));
      };
  };
  var functorFn = {
      map: Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn)
  };
  var functorArray = {
      map: $foreign.arrayMap
  };
  exports["map"] = map;
  exports["mapFlipped"] = mapFlipped;
  exports["void"] = $$void;
  exports["voidRight"] = voidRight;
  exports["voidLeft"] = voidLeft;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var $foreign = $PS["Control.Apply"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var applyArray = {
      apply: $foreign.arrayApply,
      Functor0: function () {
          return Data_Functor.functorArray;
      }
  };
  var apply = function (dict) {
      return dict.apply;
  };
  var applyFirst = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"])(a))(b);
          };
      };
  };
  exports["apply"] = apply;
  exports["applyFirst"] = applyFirst;
  exports["applyArray"] = applyArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];          
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = {
      identity: function (x) {
          return x;
      },
      Semigroupoid0: function () {
          return Control_Semigroupoid.semigroupoidFn;
      }
  };
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var $foreign = $PS["Control.Bind"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var bindArray = {
      bind: $foreign.arrayBind,
      Apply0: function () {
          return Control_Apply.applyArray;
      }
  };
  var bind = function (dict) {
      return dict.bind;
  };
  var bindFlipped = function (dictBind) {
      return Data_Function.flip(bind(dictBind));
  };
  var composeKleisliFlipped = function (dictBind) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return bindFlipped(dictBind)(f)(g(a));
              };
          };
      };
  };
  var join = function (dictBind) {
      return function (m) {
          return bind(dictBind)(m)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  exports["bind"] = bind;
  exports["bindFlipped"] = bindFlipped;
  exports["join"] = join;
  exports["composeKleisliFlipped"] = composeKleisliFlipped;
  exports["bindArray"] = bindArray;
})(PS);
(function(exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Array creation --------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.range = function (start) {
    return function (end) {
      var step = start > end ? -1 : 1;
      var result = new Array(step * (end - start) + 1);
      var i = start, n = 0;
      while (i !== end) {
        result[n++] = i;
        i += step;
      }
      result[n] = i;
      return result;
    };
  };

  var replicateFill = function (count) {
    return function (value) {
      if (count < 1) {
        return [];
      }
      var result = new Array(count);
      return result.fill(value);
    };
  };

  var replicatePolyfill = function (count) {
    return function (value) {
      var result = [];
      var n = 0;
      for (var i = 0; i < count; i++) {
        result[n++] = value;
      }
      return result;
    };
  };

  // In browsers that have Array.prototype.fill we use it, as it's faster.
  exports.replicate = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Non-indexed reads -----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.unconsImpl = function (empty) {
    return function (next) {
      return function (xs) {
        return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));
      };
    };
  };

  //------------------------------------------------------------------------------
  // Indexed operations ----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.indexImpl = function (just) {
    return function (nothing) {
      return function (xs) {
        return function (i) {
          return i < 0 || i >= xs.length ? nothing :  just(xs[i]);
        };
      };
    };
  };

  exports.findMapImpl = function (nothing) {
    return function (isJust) {
      return function (f) {
        return function (xs) {
          for (var i = 0; i < xs.length; i++) {
            var result = f(xs[i]);
            if (isJust(result)) return result;
          }
          return nothing;
        };
      };
    };
  };

  exports.findIndexImpl = function (just) {
    return function (nothing) {
      return function (f) {
        return function (xs) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (f(xs[i])) return just(i);
          }
          return nothing;
        };
      };
    };
  };

  exports._deleteAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (l) {
          if (i < 0 || i >= l.length) return nothing;
          var l1 = l.slice();
          l1.splice(i, 1);
          return just(l1);
        };
      };
    };
  };

  exports.filter = function (f) {
    return function (xs) {
      return xs.filter(f);
    };
  };

  //------------------------------------------------------------------------------
  // Sorting ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.sortByImpl = (function () {
    function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;

      mid = from + ((to - from) >> 1);
      if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);

      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        }
        else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }

    return function (compare) {
      return function (fromOrdering) {
        return function (xs) {
          var out;

          if (xs.length < 2) return xs;

          out = xs.slice(0);
          mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);

          return out;
        };
      };
    };
  })();

  //------------------------------------------------------------------------------
  // Subarrays -------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.slice = function (s) {
    return function (e) {
      return function (l) {
        return l.slice(s, e);
      };
    };
  };

  //------------------------------------------------------------------------------
  // Zipping ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.zipWith = function (f) {
    return function (xs) {
      return function (ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        var result = new Array(l);
        for (var i = 0; i < l; i++) {
          result[i] = f(xs[i])(ys[i]);
        }
        return result;
      };
    };
  };

  //------------------------------------------------------------------------------
  // Partial ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.unsafeIndexImpl = function (xs) {
    return function (n) {
      return xs[n];
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  "use strict";

  exports.map_ = function (f) {
    return function (a) {
      return function () {
        return f(a());
      };
    };
  };

  exports.pure_ = function (a) {
    return function () {
      return a;
    };
  };

  exports.bind_ = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports["for"] = function (lo) {
    return function (hi) {
      return function (f) {
        return function () {
          for (var i = lo; i < hi; i++) {
            f(i)();
          }
        };
      };
    };
  };

  exports.new = function (val) {
    return function () {
      return { value: val };
    };
  };

  exports.read = function (ref) {
    return function () {
      return ref.value;
    };
  };

  exports.modifyImpl = function (f) {
    return function (ref) {
      return function () {
        var t = f(ref.value);
        ref.value = t.state;
        return t.value;
      };
    };
  };

  exports.write = function (a) {
    return function (ref) {
      return function () {
        return ref.value = a; // eslint-disable-line no-return-assign
      };
    };
  };
})(PS["Control.Monad.ST.Internal"] = PS["Control.Monad.ST.Internal"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["ap"] = ap;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Monad.ST.Internal"] = $PS["Control.Monad.ST.Internal"] || {};
  var exports = $PS["Control.Monad.ST.Internal"];
  var $foreign = $PS["Control.Monad.ST.Internal"];
  var Control_Monad = $PS["Control.Monad"];        
  var modify$prime = $foreign.modifyImpl;
  var modify = function (f) {
      return modify$prime(function (s) {
          var s$prime = f(s);
          return {
              state: s$prime,
              value: s$prime
          };
      });
  };
  var functorST = {
      map: $foreign.map_
  };
  var monadST = {
      Applicative0: function () {
          return applicativeST;
      },
      Bind1: function () {
          return bindST;
      }
  };
  var bindST = {
      bind: $foreign.bind_,
      Apply0: function () {
          return applyST;
      }
  };
  var applyST = {
      apply: Control_Monad.ap(monadST),
      Functor0: function () {
          return functorST;
      }
  };
  var applicativeST = {
      pure: $foreign.pure_,
      Apply0: function () {
          return applyST;
      }
  };
  exports["modify"] = modify;
  exports["functorST"] = functorST;
  exports["bindST"] = bindST;
  exports["for"] = $foreign["for"];
  exports["new"] = $foreign["new"];
  exports["read"] = $foreign.read;
  exports["write"] = $foreign.write;
})(PS);
(function(exports) {
  "use strict";

  exports["new"] = function () {
    return [];
  };

  exports.pushAll = function (as) {
    return function (xs) {
      return function () {
        return xs.push.apply(xs, as);
      };
    };
  };

  exports.unsafeFreeze = function (xs) {
    return function () {
      return xs;
    };
  };

  function copyImpl(xs) {
    return function () {
      return xs.slice();
    };
  }                         

  exports.thaw = copyImpl;
})(PS["Data.Array.ST"] = PS["Data.Array.ST"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Array.ST"] = $PS["Data.Array.ST"] || {};
  var exports = $PS["Data.Array.ST"];
  var $foreign = $PS["Data.Array.ST"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var withArray = function (f) {
      return function (xs) {
          return function __do() {
              var result = $foreign.thaw(xs)();
              f(result)();
              return $foreign.unsafeFreeze(result)();
          };
      };
  };                                                                               
  var run = function (st) {
      return Control_Bind.bind(Control_Monad_ST_Internal.bindST)(st)($foreign.unsafeFreeze)();
  };
  var push = function (a) {
      return $foreign.pushAll([ a ]);
  };
  exports["run"] = run;
  exports["withArray"] = withArray;
  exports["push"] = push;
  exports["new"] = $foreign["new"];
  exports["unsafeFreeze"] = $foreign.unsafeFreeze;
})(PS);
(function(exports) {
  "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.HeytingAlgebra"] = $PS["Data.HeytingAlgebra"] || {};
  var exports = $PS["Data.HeytingAlgebra"];
  var $foreign = $PS["Data.HeytingAlgebra"];
  var not = function (dict) {
      return dict.not;
  };
  var disj = function (dict) {
      return dict.disj;
  };
  var heytingAlgebraBoolean = {
      ff: false,
      tt: true,
      implies: function (a) {
          return function (b) {
              return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
          };
      },
      conj: $foreign.boolConj,
      disj: $foreign.boolDisj,
      not: $foreign.boolNot
  };
  exports["not"] = not;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];        
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 230, column 1 - line 230, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var isNothing = maybe(true)(Data_Function["const"](false));
  var isJust = maybe(false)(Data_Function["const"](true));
  var functorMaybe = {
      map: function (v) {
          return function (v1) {
              if (v1 instanceof Just) {
                  return new Just(v(v1.value0));
              };
              return Nothing.value;
          };
      }
  };
  var fromMaybe = function (a) {
      return maybe(a)(Control_Category.identity(Control_Category.categoryFn));
  };
  var fromJust = function () {
      return function (v) {
          if (v instanceof Just) {
              return v.value0;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 281, column 1 - line 281, column 46): " + [ v.constructor.name ]);
      };
  };
  var altMaybe = {
      alt: function (v) {
          return function (v1) {
              if (v instanceof Nothing) {
                  return v1;
              };
              return v;
          };
      },
      Functor0: function () {
          return functorMaybe;
      }
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
  exports["fromMaybe"] = fromMaybe;
  exports["isJust"] = isJust;
  exports["isNothing"] = isNothing;
  exports["fromJust"] = fromJust;
  exports["functorMaybe"] = functorMaybe;
  exports["altMaybe"] = altMaybe;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Array.ST.Iterator"] = $PS["Data.Array.ST.Iterator"] || {};
  var exports = $PS["Data.Array.ST.Iterator"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var Data_Array_ST = $PS["Data.Array.ST"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var Iterator = (function () {
      function Iterator(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Iterator.create = function (value0) {
          return function (value1) {
              return new Iterator(value0, value1);
          };
      };
      return Iterator;
  })();
  var peek = function (v) {
      return function __do() {
          var i = Control_Monad_ST_Internal.read(v.value1)();
          return v.value0(i);
      };
  };
  var next = function (v) {
      return function __do() {
          var i = Control_Monad_ST_Internal.read(v.value1)();
          Control_Monad_ST_Internal.modify(function (v1) {
              return v1 + 1 | 0;
          })(v.value1)();
          return v.value0(i);
      };
  };
  var pushWhile = function (p) {
      return function (iter) {
          return function (array) {
              return function __do() {
                  var $$break = Control_Monad_ST_Internal["new"](false)();
                  while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read($$break))()) {
                      (function __do() {
                          var mx = peek(iter)();
                          if (mx instanceof Data_Maybe.Just && p(mx.value0)) {
                              Data_Array_ST.push(mx.value0)(array)();
                              return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(next(iter))();
                          };
                          return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)($$break))();
                      })();
                  };
                  return {};
              };
          };
      };
  };                                                    
  var iterator = function (f) {
      return Data_Functor.map(Control_Monad_ST_Internal.functorST)(Iterator.create(f))(Control_Monad_ST_Internal["new"](0));
  };
  var iterate = function (iter) {
      return function (f) {
          return function __do() {
              var $$break = Control_Monad_ST_Internal["new"](false)();
              while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read($$break))()) {
                  (function __do() {
                      var mx = next(iter)();
                      if (mx instanceof Data_Maybe.Just) {
                          return f(mx.value0)();
                      };
                      if (mx instanceof Data_Maybe.Nothing) {
                          return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)($$break))();
                      };
                      throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [ mx.constructor.name ]);
                  })();
              };
              return {};
          };
      };
  };
  exports["iterator"] = iterator;
  exports["iterate"] = iterate;
  exports["pushWhile"] = pushWhile;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function(exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };                            
  exports.eqIntImpl = refEq;   
  exports.eqCharImpl = refEq;
  exports.eqStringImpl = refEq;

  exports.eqArrayImpl = function (f) {
    return function (xs) {
      return function (ys) {
        if (xs.length !== ys.length) return false;
        for (var i = 0; i < xs.length; i++) {
          if (!f(xs[i])(ys[i])) return false;
        }
        return true;
      };
    };
  };
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var eqString = {
      eq: $foreign.eqStringImpl
  };
  var eqInt = {
      eq: $foreign.eqIntImpl
  };
  var eqChar = {
      eq: $foreign.eqCharImpl
  };
  var eq = function (dict) {
      return dict.eq;
  };
  var eqArray = function (dictEq) {
      return {
          eq: $foreign.eqArrayImpl(eq(dictEq))
      };
  };
  exports["eq"] = eq;
  exports["eqInt"] = eqInt;
  exports["eqChar"] = eqChar;
  exports["eqString"] = eqString;
  exports["eqArray"] = eqArray;
})(PS);
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
  "use strict";

  exports.intDegree = function (x) {
    return Math.min(Math.abs(x), 2147483647);
  };

  // See the Euclidean definition in
  // https://en.m.wikipedia.org/wiki/Modulo_operation.
  exports.intDiv = function (x) {
    return function (y) {
      if (y === 0) return 0;
      return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
    };
  };

  exports.intMod = function (x) {
    return function (y) {
      if (y === 0) return 0;
      var yy = Math.abs(y);
      return ((x % yy) + yy) % yy;
    };
  };
})(PS["Data.EuclideanRing"] = PS["Data.EuclideanRing"] || {});
(function(exports) {
  "use strict";

  exports.intSub = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x - y | 0;
    };
  };
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
  "use strict";

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x + y | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x * y | 0;
    };
  };
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Semiring"] = $PS["Data.Semiring"] || {};
  var exports = $PS["Data.Semiring"];
  var $foreign = $PS["Data.Semiring"];
  var zero = function (dict) {
      return dict.zero;
  };
  var semiringInt = {
      add: $foreign.intAdd,
      zero: 0,
      mul: $foreign.intMul,
      one: 1
  };
  exports["zero"] = zero;
  exports["semiringInt"] = semiringInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Ring"] = $PS["Data.Ring"] || {};
  var exports = $PS["Data.Ring"];
  var $foreign = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var sub = function (dict) {
      return dict.sub;
  };
  var ringInt = {
      sub: $foreign.intSub,
      Semiring0: function () {
          return Data_Semiring.semiringInt;
      }
  };
  var negate = function (dictRing) {
      return function (a) {
          return sub(dictRing)(Data_Semiring.zero(dictRing.Semiring0()))(a);
      };
  };
  exports["negate"] = negate;
  exports["ringInt"] = ringInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.CommutativeRing"] = $PS["Data.CommutativeRing"] || {};
  var exports = $PS["Data.CommutativeRing"];
  var Data_Ring = $PS["Data.Ring"];
  var commutativeRingInt = {
      Ring0: function () {
          return Data_Ring.ringInt;
      }
  };
  exports["commutativeRingInt"] = commutativeRingInt;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.EuclideanRing"] = $PS["Data.EuclideanRing"] || {};
  var exports = $PS["Data.EuclideanRing"];
  var $foreign = $PS["Data.EuclideanRing"];
  var Data_CommutativeRing = $PS["Data.CommutativeRing"];  
  var mod = function (dict) {
      return dict.mod;
  };
  var euclideanRingInt = {
      degree: $foreign.intDegree,
      div: $foreign.intDiv,
      mod: $foreign.intMod,
      CommutativeRing0: function () {
          return Data_CommutativeRing.commutativeRingInt;
      }
  };
  var div = function (dict) {
      return dict.div;
  };
  exports["div"] = div;
  exports["mod"] = mod;
  exports["euclideanRingInt"] = euclideanRingInt;
})(PS);
(function(exports) {
  "use strict";

  exports.concatString = function (s1) {
    return function (s2) {
      return s1 + s2;
    };
  };

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var semigroupString = {
      append: $foreign.concatString
  };
  var semigroupArray = {
      append: $foreign.concatArray
  };
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
  exports["semigroupString"] = semigroupString;
  exports["semigroupArray"] = semigroupArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var monoidString = {
      mempty: "",
      Semigroup0: function () {
          return Data_Semigroup.semigroupString;
      }
  };
  var monoidArray = {
      mempty: [  ],
      Semigroup0: function () {
          return Data_Semigroup.semigroupArray;
      }
  };
  var mempty = function (dict) {
      return dict.mempty;
  };
  var power = function (dictMonoid) {
      return function (x) {
          var go = function (p) {
              if (p <= 0) {
                  return mempty(dictMonoid);
              };
              if (p === 1) {
                  return x;
              };
              if (Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(p)(2) === 0) {
                  var x$prime = go(Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(p)(2));
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(x$prime);
              };
              if (Data_Boolean.otherwise) {
                  var x$prime = go(Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(p)(2));
                  return Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(x));
              };
              throw new Error("Failed pattern match at Data.Monoid (line 86, column 3 - line 86, column 17): " + [ p.constructor.name ]);
          };
          return go;
      };
  };
  exports["mempty"] = mempty;
  exports["power"] = power;
  exports["monoidString"] = monoidString;
  exports["monoidArray"] = monoidArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Category = $PS["Control.Category"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];      
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  };
  var intercalate = function (dictFoldable) {
      return function (dictMonoid) {
          return function (sep) {
              return function (xs) {
                  var go = function (v) {
                      return function (x) {
                          if (v.init) {
                              return {
                                  init: false,
                                  acc: x
                              };
                          };
                          return {
                              init: false,
                              acc: Data_Semigroup.append(dictMonoid.Semigroup0())(v.acc)(Data_Semigroup.append(dictMonoid.Semigroup0())(sep)(x))
                          };
                      };
                  };
                  return (foldl(dictFoldable)(go)({
                      init: true,
                      acc: Data_Monoid.mempty(dictMonoid)
                  })(xs)).acc;
              };
          };
      };
  };
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = {
      foldr: $foreign.foldrArray,
      foldl: $foreign.foldlArray,
      foldMap: function (dictMonoid) {
          return foldMapDefaultR(foldableArray)(dictMonoid);
      }
  };
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  var fold = function (dictFoldable) {
      return function (dictMonoid) {
          return foldMap(dictFoldable)(dictMonoid)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  exports["foldr"] = foldr;
  exports["foldl"] = foldl;
  exports["foldMap"] = foldMap;
  exports["fold"] = fold;
  exports["intercalate"] = intercalate;
  exports["foldableArray"] = foldableArray;
})(PS);
(function(exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };                                         
  exports.ordIntImpl = unsafeCompareImpl;   
  exports.ordStringImpl = unsafeCompareImpl;
  exports.ordCharImpl = unsafeCompareImpl;

  exports.ordArrayImpl = function (f) {
    return function (xs) {
      return function (ys) {
        var i = 0;
        var xlen = xs.length;
        var ylen = ys.length;
        while (i < xlen && i < ylen) {
          var x = xs[i];
          var y = ys[i];
          var o = f(x)(y);
          if (o !== 0) {
            return o;
          }
          i++;
        }
        if (xlen === ylen) {
          return 0;
        } else if (xlen > ylen) {
          return -1;
        } else {
          return 1;
        }
      };
    };
  };
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Ring = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var ordString = {
      compare: $foreign.ordStringImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),
      Eq0: function () {
          return Data_Eq.eqString;
      }
  };
  var ordInt = {
      compare: $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),
      Eq0: function () {
          return Data_Eq.eqInt;
      }
  };
  var ordChar = {
      compare: $foreign.ordCharImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),
      Eq0: function () {
          return Data_Eq.eqChar;
      }
  };
  var compare = function (dict) {
      return dict.compare;
  };
  var comparing = function (dictOrd) {
      return function (f) {
          return function (x) {
              return function (y) {
                  return compare(dictOrd)(f(x))(f(y));
              };
          };
      };
  };
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };
  var max = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return y;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return x;
              };
              throw new Error("Failed pattern match at Data.Ord (line 176, column 3 - line 179, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  var ordArray = function (dictOrd) {
      return {
          compare: (function () {
              var toDelta = function (x) {
                  return function (y) {
                      var v = compare(dictOrd)(x)(y);
                      if (v instanceof Data_Ordering.EQ) {
                          return 0;
                      };
                      if (v instanceof Data_Ordering.LT) {
                          return 1;
                      };
                      if (v instanceof Data_Ordering.GT) {
                          return -1 | 0;
                      };
                      throw new Error("Failed pattern match at Data.Ord (line 74, column 7 - line 77, column 17): " + [ v.constructor.name ]);
                  };
              };
              return function (xs) {
                  return function (ys) {
                      return compare(ordInt)(0)($foreign.ordArrayImpl(toDelta)(xs)(ys));
                  };
              };
          })(),
          Eq0: function () {
              return Data_Eq.eqArray(dictOrd.Eq0());
          }
      };
  };
  var abs = function (dictOrd) {
      return function (dictRing) {
          return function (x) {
              var $60 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing.Semiring0()));
              if ($60) {
                  return x;
              };
              return Data_Ring.negate(dictRing)(x);
          };
      };
  };
  exports["compare"] = compare;
  exports["comparing"] = comparing;
  exports["max"] = max;
  exports["abs"] = abs;
  exports["ordInt"] = ordInt;
  exports["ordString"] = ordString;
  exports["ordChar"] = ordChar;
  exports["ordArray"] = ordArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Tuple"] = $PS["Data.Tuple"] || {};
  var exports = $PS["Data.Tuple"];                 
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  var fst = function (v) {
      return v.value0;
  };
  exports["Tuple"] = Tuple;
  exports["fst"] = fst;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Control_Monad_ST_Internal = $PS["Control.Monad.ST.Internal"];
  var Data_Array_ST = $PS["Data.Array.ST"];
  var Data_Array_ST_Iterator = $PS["Data.Array.ST.Iterator"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Tuple = $PS["Data.Tuple"];
  var zip = $foreign.zipWith(Data_Tuple.Tuple.create);                                   
  var unsafeIndex = function () {
      return $foreign.unsafeIndexImpl;
  };
  var uncons = $foreign.unconsImpl(Data_Function["const"](Data_Maybe.Nothing.value))(function (x) {
      return function (xs) {
          return new Data_Maybe.Just({
              head: x,
              tail: xs
          });
      };
  });
  var sortBy = function (comp) {
      return $foreign.sortByImpl(comp)(function (v) {
          if (v instanceof Data_Ordering.GT) {
              return 1;
          };
          if (v instanceof Data_Ordering.EQ) {
              return 0;
          };
          if (v instanceof Data_Ordering.LT) {
              return -1 | 0;
          };
          throw new Error("Failed pattern match at Data.Array (line 831, column 31 - line 834, column 11): " + [ v.constructor.name ]);
      });
  };
  var sort = function (dictOrd) {
      return function (xs) {
          return sortBy(Data_Ord.compare(dictOrd))(xs);
      };
  };
  var snoc = function (xs) {
      return function (x) {
          return Data_Array_ST.withArray(Data_Array_ST.push(x))(xs)();
      };
  };
  var $$null = function (xs) {
      return $foreign.length(xs) === 0;
  };
  var intersperse = function (a) {
      return function (arr) {
          var v = $foreign.length(arr);
          if (v < 2) {
              return arr;
          };
          if (Data_Boolean.otherwise) {
              return Data_Array_ST.run((function () {
                  var unsafeGetElem = function (idx) {
                      return unsafeIndex()(arr)(idx);
                  };
                  return function __do() {
                      var out = Data_Array_ST["new"]();
                      Data_Array_ST.push(unsafeGetElem(0))(out)();
                      Control_Monad_ST_Internal["for"](1)(v)(function (idx) {
                          return function __do() {
                              Data_Array_ST.push(a)(out)();
                              return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(unsafeGetElem(idx))(out))();
                          };
                      })();
                      return out;
                  };
              })());
          };
          throw new Error("Failed pattern match at Data.Array (line 613, column 21 - line 622, column 19): " + [ v.constructor.name ]);
      };
  };
  var intercalate = function (dictMonoid) {
      return Data_Foldable.intercalate(Data_Foldable.foldableArray)(dictMonoid);
  };
  var index = $foreign.indexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var groupBy = function (op) {
      return function (xs) {
          return (function __do() {
              var result = Data_Array_ST["new"]();
              var iter = Data_Array_ST_Iterator.iterator(function (v) {
                  return index(xs)(v);
              })();
              Data_Array_ST_Iterator.iterate(iter)(function (x) {
                  return Data_Functor["void"](Control_Monad_ST_Internal.functorST)(function __do() {
                      var sub = Data_Array_ST["new"]();
                      Data_Array_ST.push(x)(sub)();
                      Data_Array_ST_Iterator.pushWhile(op(x))(iter)(sub)();
                      var grp = Data_Array_ST.unsafeFreeze(sub)();
                      return Data_Array_ST.push(grp)(result)();
                  });
              })();
              return Data_Array_ST.unsafeFreeze(result)();
          })();
      };
  };
  var foldr = Data_Foldable.foldr(Data_Foldable.foldableArray);
  var foldl = Data_Foldable.foldl(Data_Foldable.foldableArray);
  var findMap = $foreign.findMapImpl(Data_Maybe.Nothing.value)(Data_Maybe.isJust);
  var findIndex = $foreign.findIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var elemIndex = function (dictEq) {
      return function (x) {
          return findIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };
  var elem = function (dictEq) {
      return function (a) {
          return function (arr) {
              return Data_Maybe.isJust(elemIndex(dictEq)(a)(arr));
          };
      };
  };
  var drop = function (n) {
      return function (xs) {
          var $80 = n < 1;
          if ($80) {
              return xs;
          };
          return $foreign.slice(n)($foreign.length(xs))(xs);
      };
  };
  var deleteAt = $foreign["_deleteAt"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var deleteBy = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2.length === 0) {
                  return [  ];
              };
              return Data_Maybe.maybe(v2)(function (i) {
                  return Data_Maybe.fromJust()(deleteAt(i)(v2));
              })(findIndex(v(v1))(v2));
          };
      };
  };
  var $$delete = function (dictEq) {
      return deleteBy(Data_Eq.eq(dictEq));
  };
  var difference = function (dictEq) {
      return foldr($$delete(dictEq));
  };
  var cons = function (x) {
      return function (xs) {
          return Data_Semigroup.append(Data_Semigroup.semigroupArray)([ x ])(xs);
      };
  };
  exports["null"] = $$null;
  exports["cons"] = cons;
  exports["snoc"] = snoc;
  exports["uncons"] = uncons;
  exports["index"] = index;
  exports["elem"] = elem;
  exports["findMap"] = findMap;
  exports["intersperse"] = intersperse;
  exports["foldl"] = foldl;
  exports["intercalate"] = intercalate;
  exports["sort"] = sort;
  exports["sortBy"] = sortBy;
  exports["drop"] = drop;
  exports["groupBy"] = groupBy;
  exports["difference"] = difference;
  exports["zip"] = zip;
  exports["range"] = $foreign.range;
  exports["replicate"] = $foreign.replicate;
  exports["length"] = $foreign.length;
  exports["filter"] = $foreign.filter;
  exports["zipWith"] = $foreign.zipWith;
})(PS);
(function(exports) {
  "use strict";

  exports.foldr1Impl = function (f) {
    return function (xs) {
      var acc = xs[xs.length - 1];
      for (var i = xs.length - 2; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };

  exports.foldl1Impl = function (f) {
    return function (xs) {
      var acc = xs[0];
      var len = xs.length;
      for (var i = 1; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
})(PS["Data.Array.NonEmpty.Internal"] = PS["Data.Array.NonEmpty.Internal"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Semigroup.Foldable"] = $PS["Data.Semigroup.Foldable"] || {};
  var exports = $PS["Data.Semigroup.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var foldr1 = function (dict) {
      return dict.foldr1;
  };
  var foldl1 = function (dict) {
      return dict.foldl1;
  };
  var foldMap1DefaultL = function (dictFoldable1) {
      return function (dictFunctor) {
          return function (dictSemigroup) {
              return function (f) {
                  var $117 = foldl1(dictFoldable1)(Data_Semigroup.append(dictSemigroup));
                  var $118 = Data_Functor.map(dictFunctor)(f);
                  return function ($119) {
                      return $117($118($119));
                  };
              };
          };
      };
  };
  exports["foldr1"] = foldr1;
  exports["foldMap1DefaultL"] = foldMap1DefaultL;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Array.NonEmpty.Internal"] = $PS["Data.Array.NonEmpty.Internal"] || {};
  var exports = $PS["Data.Array.NonEmpty.Internal"];
  var $foreign = $PS["Data.Array.NonEmpty.Internal"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Semigroup_Foldable = $PS["Data.Semigroup.Foldable"];  
  var NonEmptyArray = function (x) {
      return x;
  };                                                                              
  var functorNonEmptyArray = Data_Functor.functorArray;                              
  var foldableNonEmptyArray = Data_Foldable.foldableArray;
  var foldable1NonEmptyArray = {
      foldMap1: function (dictSemigroup) {
          return Data_Semigroup_Foldable.foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);
      },
      foldr1: $foreign.foldr1Impl,
      foldl1: $foreign.foldl1Impl,
      Foldable0: function () {
          return foldableNonEmptyArray;
      }
  };
  exports["NonEmptyArray"] = NonEmptyArray;
  exports["foldable1NonEmptyArray"] = foldable1NonEmptyArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Array.NonEmpty"] = $PS["Data.Array.NonEmpty"] || {};
  var exports = $PS["Data.Array.NonEmpty"];
  var Data_Array = $PS["Data.Array"];
  var Data_Array_NonEmpty_Internal = $PS["Data.Array.NonEmpty.Internal"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Semigroup_Foldable = $PS["Data.Semigroup.Foldable"];
  var unsafeFromArray = Data_Array_NonEmpty_Internal.NonEmptyArray;
  var toArray = function (v) {
      return v;
  };
  var fromArray = function (xs) {
      if (Data_Array.length(xs) > 0) {
          return new Data_Maybe.Just(unsafeFromArray(xs));
      };
      if (Data_Boolean.otherwise) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Data.Array.NonEmpty (line 159, column 1 - line 159, column 58): " + [ xs.constructor.name ]);
  };
  var foldr1 = Data_Semigroup_Foldable.foldr1(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray);
  var adaptAny = function (f) {
      return function ($74) {
          return f(toArray($74));
      };
  };                                     
  var length = adaptAny(Data_Array.length);
  exports["fromArray"] = fromArray;
  exports["toArray"] = toArray;
  exports["foldr1"] = foldr1;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];              
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  var note = function (a) {
      return Data_Maybe.maybe(new Left(a))(Right.create);
  };
  var functorEither = {
      map: function (f) {
          return function (m) {
              if (m instanceof Left) {
                  return new Left(m.value0);
              };
              if (m instanceof Right) {
                  return new Right(f(m.value0));
              };
              throw new Error("Failed pattern match at Data.Either (line 31, column 1 - line 31, column 52): " + [ m.constructor.name ]);
          };
      }
  };
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var applyEither = {
      apply: function (v) {
          return function (v1) {
              if (v instanceof Left) {
                  return new Left(v.value0);
              };
              if (v instanceof Right) {
                  return Data_Functor.map(functorEither)(v.value0)(v1);
              };
              throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [ v.constructor.name, v1.constructor.name ]);
          };
      },
      Functor0: function () {
          return functorEither;
      }
  };
  var bindEither = {
      bind: either(function (e) {
          return function (v) {
              return new Left(e);
          };
      })(function (a) {
          return function (f) {
              return f(a);
          };
      }),
      Apply0: function () {
          return applyEither;
      }
  };
  var applicativeEither = {
      pure: Right.create,
      Apply0: function () {
          return applyEither;
      }
  };
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["either"] = either;
  exports["note"] = note;
  exports["functorEither"] = functorEither;
  exports["applyEither"] = applyEither;
  exports["applicativeEither"] = applicativeEither;
  exports["bindEither"] = bindEither;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Bifunctor"] = $PS["Data.Bifunctor"] || {};
  var exports = $PS["Data.Bifunctor"];
  var Control_Category = $PS["Control.Category"];
  var Data_Either = $PS["Data.Either"];              
  var bimap = function (dict) {
      return dict.bimap;
  };
  var lmap = function (dictBifunctor) {
      return function (f) {
          return bimap(dictBifunctor)(f)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var bifunctorEither = {
      bimap: function (v) {
          return function (v1) {
              return function (v2) {
                  if (v2 instanceof Data_Either.Left) {
                      return new Data_Either.Left(v(v2.value0));
                  };
                  if (v2 instanceof Data_Either.Right) {
                      return new Data_Either.Right(v1(v2.value0));
                  };
                  throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
              };
          };
      }
  };
  exports["lmap"] = lmap;
  exports["bifunctorEither"] = bifunctorEither;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.List.Types"] = $PS["Data.List.Types"] || {};
  var exports = $PS["Data.List.Types"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var listMap = function (f) {
      var chunkedRevMap = function ($copy_chunksAcc) {
          return function ($copy_v) {
              var $tco_var_chunksAcc = $copy_chunksAcc;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(chunksAcc, v) {
                  if (v instanceof Cons && (v.value1 instanceof Cons && v.value1.value1 instanceof Cons)) {
                      $tco_var_chunksAcc = new Cons(v, chunksAcc);
                      $copy_v = v.value1.value1.value1;
                      return;
                  };
                  var unrolledMap = function (v1) {
                      if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Nil)) {
                          return new Cons(f(v1.value0), new Cons(f(v1.value1.value0), Nil.value));
                      };
                      if (v1 instanceof Cons && v1.value1 instanceof Nil) {
                          return new Cons(f(v1.value0), Nil.value);
                      };
                      return Nil.value;
                  };
                  var reverseUnrolledMap = function ($copy_v1) {
                      return function ($copy_acc) {
                          var $tco_var_v1 = $copy_v1;
                          var $tco_done1 = false;
                          var $tco_result;
                          function $tco_loop(v1, acc) {
                              if (v1 instanceof Cons && (v1.value0 instanceof Cons && (v1.value0.value1 instanceof Cons && v1.value0.value1.value1 instanceof Cons))) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_acc = new Cons(f(v1.value0.value0), new Cons(f(v1.value0.value1.value0), new Cons(f(v1.value0.value1.value1.value0), acc)));
                                  return;
                              };
                              $tco_done1 = true;
                              return acc;
                          };
                          while (!$tco_done1) {
                              $tco_result = $tco_loop($tco_var_v1, $copy_acc);
                          };
                          return $tco_result;
                      };
                  };
                  $tco_done = true;
                  return reverseUnrolledMap(chunksAcc)(unrolledMap(v));
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_chunksAcc, $copy_v);
              };
              return $tco_result;
          };
      };
      return chunkedRevMap(Nil.value);
  };
  var functorList = {
      map: listMap
  };                                                                   
  var foldableList = {
      foldr: function (f) {
          return function (b) {
              var rev = (function () {
                  var go = function ($copy_acc) {
                      return function ($copy_v) {
                          var $tco_var_acc = $copy_acc;
                          var $tco_done = false;
                          var $tco_result;
                          function $tco_loop(acc, v) {
                              if (v instanceof Nil) {
                                  $tco_done = true;
                                  return acc;
                              };
                              if (v instanceof Cons) {
                                  $tco_var_acc = new Cons(v.value0, acc);
                                  $copy_v = v.value1;
                                  return;
                              };
                              throw new Error("Failed pattern match at Data.List.Types (line 108, column 7 - line 108, column 23): " + [ acc.constructor.name, v.constructor.name ]);
                          };
                          while (!$tco_done) {
                              $tco_result = $tco_loop($tco_var_acc, $copy_v);
                          };
                          return $tco_result;
                      };
                  };
                  return go(Nil.value);
              })();
              var $205 = Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b);
              return function ($206) {
                  return $205(rev($206));
              };
          };
      },
      foldl: function (f) {
          var go = function ($copy_b) {
              return function ($copy_v) {
                  var $tco_var_b = $copy_b;
                  var $tco_done1 = false;
                  var $tco_result;
                  function $tco_loop(b, v) {
                      if (v instanceof Nil) {
                          $tco_done1 = true;
                          return b;
                      };
                      if (v instanceof Cons) {
                          $tco_var_b = f(b)(v.value0);
                          $copy_v = v.value1;
                          return;
                      };
                      throw new Error("Failed pattern match at Data.List.Types (line 112, column 12 - line 114, column 30): " + [ v.constructor.name ]);
                  };
                  while (!$tco_done1) {
                      $tco_result = $tco_loop($tco_var_b, $copy_v);
                  };
                  return $tco_result;
              };
          };
          return go;
      },
      foldMap: function (dictMonoid) {
          return function (f) {
              return Data_Foldable.foldl(foldableList)(function (acc) {
                  var $207 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);
                  return function ($208) {
                      return $207(f($208));
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      }
  };
  var semigroupList = {
      append: function (xs) {
          return function (ys) {
              return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);
          };
      }
  };
  var unfoldable1List = {
      unfoldr1: function (f) {
          return function (b) {
              var go = function ($copy_source) {
                  return function ($copy_memo) {
                      var $tco_var_source = $copy_source;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(source, memo) {
                          var v = f(source);
                          if (v.value1 instanceof Data_Maybe.Just) {
                              $tco_var_source = v.value1.value0;
                              $copy_memo = new Cons(v.value0, memo);
                              return;
                          };
                          if (v.value1 instanceof Data_Maybe.Nothing) {
                              $tco_done = true;
                              return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(new Cons(v.value0, memo));
                          };
                          throw new Error("Failed pattern match at Data.List.Types (line 136, column 22 - line 138, column 61): " + [ v.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_source, $copy_memo);
                      };
                      return $tco_result;
                  };
              };
              return go(b)(Nil.value);
          };
      }
  };
  var unfoldableList = {
      unfoldr: function (f) {
          return function (b) {
              var go = function ($copy_source) {
                  return function ($copy_memo) {
                      var $tco_var_source = $copy_source;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(source, memo) {
                          var v = f(source);
                          if (v instanceof Data_Maybe.Nothing) {
                              $tco_done = true;
                              return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(memo);
                          };
                          if (v instanceof Data_Maybe.Just) {
                              $tco_var_source = v.value0.value1;
                              $copy_memo = new Cons(v.value0.value0, memo);
                              return;
                          };
                          throw new Error("Failed pattern match at Data.List.Types (line 143, column 22 - line 145, column 52): " + [ v.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_source, $copy_memo);
                      };
                      return $tco_result;
                  };
              };
              return go(b)(Nil.value);
          };
      },
      Unfoldable10: function () {
          return unfoldable1List;
      }
  };
  var applyList = {
      apply: function (v) {
          return function (v1) {
              if (v instanceof Nil) {
                  return Nil.value;
              };
              if (v instanceof Cons) {
                  return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));
              };
              throw new Error("Failed pattern match at Data.List.Types (line 158, column 1 - line 160, column 48): " + [ v.constructor.name, v1.constructor.name ]);
          };
      },
      Functor0: function () {
          return functorList;
      }
  };
  var applicativeList = {
      pure: function (a) {
          return new Cons(a, Nil.value);
      },
      Apply0: function () {
          return applyList;
      }
  };
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["semigroupList"] = semigroupList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["unfoldableList"] = unfoldableList;
  exports["applicativeList"] = applicativeList;
})(PS);
(function(exports) {
  "use strict";

  exports.unfoldrArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var maybe = f(value);
                if (isNothing(maybe)) return result;
                var tuple = fromJust(maybe);
                result.push(fst(tuple));
                value = snd(tuple);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  "use strict";

  exports.unfoldr1ArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              var value = b;
              while (true) { // eslint-disable-line no-constant-condition
                var tuple = f(value);
                result.push(fst(tuple));
                var maybe = snd(tuple);
                if (isNothing(maybe)) return result;
                value = fromJust(maybe);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable1"] = PS["Data.Unfoldable1"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Unfoldable1"] = $PS["Data.Unfoldable1"] || {};
  var exports = $PS["Data.Unfoldable1"];
  var $foreign = $PS["Data.Unfoldable1"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var unfoldable1Array = {
      unfoldr1: $foreign.unfoldr1ArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd)
  };
  exports["unfoldable1Array"] = unfoldable1Array;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Unfoldable"] = $PS["Data.Unfoldable"] || {};
  var exports = $PS["Data.Unfoldable"];
  var $foreign = $PS["Data.Unfoldable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable1 = $PS["Data.Unfoldable1"];  
  var unfoldr = function (dict) {
      return dict.unfoldr;
  };
  var unfoldableArray = {
      unfoldr: $foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd),
      Unfoldable10: function () {
          return Data_Unfoldable1.unfoldable1Array;
      }
  };
  exports["unfoldr"] = unfoldr;
  exports["unfoldableArray"] = unfoldableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.List"] = $PS["Data.List"] || {};
  var exports = $PS["Data.List"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                                  
  var uncons = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just({
              head: v.value0,
              tail: v.value1
          });
      };
      throw new Error("Failed pattern match at Data.List (line 263, column 1 - line 263, column 66): " + [ v.constructor.name ]);
  };
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(uncons(xs));
      });
  };
  var tail = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value1);
      };
      throw new Error("Failed pattern match at Data.List (line 249, column 1 - line 249, column 43): " + [ v.constructor.name ]);
  };
  var head = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value0);
      };
      throw new Error("Failed pattern match at Data.List (line 234, column 1 - line 234, column 22): " + [ v.constructor.name ]);
  };
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
  };
  exports["toUnfoldable"] = toUnfoldable;
  exports["fromFoldable"] = fromFoldable;
})(PS);
(function(exports) {
  "use strict";
  /* global Symbol */

  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator =
    typeof Symbol !== "undefined" &&
    Symbol != null &&
    typeof Symbol.iterator !== "undefined" &&
    typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";

  exports._unsafeCodePointAt0 = function (fallback) {
    return hasCodePointAt
      ? function (str) { return str.codePointAt(0); }
      : fallback;
  };

  exports._singleton = function (fallback) {
    return hasFromCodePoint ? String.fromCodePoint : fallback;
  };

  exports._take = function (fallback) {
    return function (n) {
      if (hasStringIterator) {
        return function (str) {
          var accum = "";
          var iter = str[Symbol.iterator]();
          for (var i = 0; i < n; ++i) {
            var o = iter.next();
            if (o.done) return accum;
            accum += o.value;
          }
          return accum;
        };
      }
      return fallback(n);
    };
  };

  exports._toCodePointArray = function (fallback) {
    return function (unsafeCodePointAt0) {
      if (hasArrayFrom) {
        return function (str) {
          return Array.from(str, unsafeCodePointAt0);
        };
      }
      return fallback;
    };
  };
})(PS["Data.String.CodePoints"] = PS["Data.String.CodePoints"] || {});
(function(exports) {
  "use strict";

  exports.topInt = 2147483647;
  exports.bottomInt = -2147483648;

  exports.topChar = String.fromCharCode(65535);
  exports.bottomChar = String.fromCharCode(0);
})(PS["Data.Bounded"] = PS["Data.Bounded"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Bounded"] = $PS["Data.Bounded"] || {};
  var exports = $PS["Data.Bounded"];
  var $foreign = $PS["Data.Bounded"];
  var Data_Ord = $PS["Data.Ord"];
  var top = function (dict) {
      return dict.top;
  };
  var boundedInt = {
      top: $foreign.topInt,
      bottom: $foreign.bottomInt,
      Ord0: function () {
          return Data_Ord.ordInt;
      }
  };
  var boundedChar = {
      top: $foreign.topChar,
      bottom: $foreign.bottomChar,
      Ord0: function () {
          return Data_Ord.ordChar;
      }
  };
  var bottom = function (dict) {
      return dict.bottom;
  };
  exports["bottom"] = bottom;
  exports["top"] = top;
  exports["boundedInt"] = boundedInt;
  exports["boundedChar"] = boundedChar;
})(PS);
(function(exports) {
  "use strict";

  exports.toCharCode = function (c) {
    return c.charCodeAt(0);
  };

  exports.fromCharCode = function (c) {
    return String.fromCharCode(c);
  };
})(PS["Data.Enum"] = PS["Data.Enum"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Enum"] = $PS["Data.Enum"] || {};
  var exports = $PS["Data.Enum"];
  var $foreign = $PS["Data.Enum"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var toEnum = function (dict) {
      return dict.toEnum;
  };
  var fromEnum = function (dict) {
      return dict.fromEnum;
  };
  var toEnumWithDefaults = function (dictBoundedEnum) {
      return function (low) {
          return function (high) {
              return function (x) {
                  var v = toEnum(dictBoundedEnum)(x);
                  if (v instanceof Data_Maybe.Just) {
                      return v.value0;
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      var $54 = x < fromEnum(dictBoundedEnum)(Data_Bounded.bottom(dictBoundedEnum.Bounded0()));
                      if ($54) {
                          return low;
                      };
                      return high;
                  };
                  throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [ v.constructor.name ]);
              };
          };
      };
  };
  var defaultSucc = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) + 1 | 0);
          };
      };
  };
  var defaultPred = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) - 1 | 0);
          };
      };
  };
  var charToEnum = function (v) {
      if (v >= Data_Bounded.bottom(Data_Bounded.boundedInt) && v <= Data_Bounded.top(Data_Bounded.boundedInt)) {
          return new Data_Maybe.Just($foreign.fromCharCode(v));
      };
      return Data_Maybe.Nothing.value;
  };
  var enumChar = {
      succ: defaultSucc(charToEnum)($foreign.toCharCode),
      pred: defaultPred(charToEnum)($foreign.toCharCode),
      Ord0: function () {
          return Data_Ord.ordChar;
      }
  };
  var boundedEnumChar = {
      cardinality: $foreign.toCharCode(Data_Bounded.top(Data_Bounded.boundedChar)) - $foreign.toCharCode(Data_Bounded.bottom(Data_Bounded.boundedChar)) | 0,
      toEnum: charToEnum,
      fromEnum: $foreign.toCharCode,
      Bounded0: function () {
          return Data_Bounded.boundedChar;
      },
      Enum1: function () {
          return enumChar;
      }
  };
  exports["fromEnum"] = fromEnum;
  exports["toEnumWithDefaults"] = toEnumWithDefaults;
  exports["boundedEnumChar"] = boundedEnumChar;
})(PS);
(function(exports) {
  "use strict";

  exports.singleton = function (c) {
    return c;
  };

  exports.length = function (s) {
    return s.length;
  };

  exports.take = function (n) {
    return function (s) {
      return s.substr(0, n);
    };
  };

  exports.drop = function (n) {
    return function (s) {
      return s.substring(n);
    };
  };

  exports.splitAt = function (i) {
    return function (s) {
      return { before: s.substring(0, i), after: s.substring(i) };
    };
  };
})(PS["Data.String.CodeUnits"] = PS["Data.String.CodeUnits"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.CodeUnits"] = $PS["Data.String.CodeUnits"] || {};
  var exports = $PS["Data.String.CodeUnits"];
  var $foreign = $PS["Data.String.CodeUnits"];
  var Data_Maybe = $PS["Data.Maybe"];
  var stripPrefix = function (v) {
      return function (str) {
          var v1 = $foreign.splitAt($foreign.length(v))(str);
          var $15 = v1.before === v;
          if ($15) {
              return new Data_Maybe.Just(v1.after);
          };
          return Data_Maybe.Nothing.value;
      };
  };
  exports["stripPrefix"] = stripPrefix;
  exports["singleton"] = $foreign.singleton;
  exports["length"] = $foreign.length;
  exports["take"] = $foreign.take;
  exports["drop"] = $foreign.drop;
})(PS);
(function(exports) {
  "use strict";

  exports.charAt = function (i) {
    return function (s) {
      if (i >= 0 && i < s.length) return s.charAt(i);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };
})(PS["Data.String.Unsafe"] = PS["Data.String.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.Unsafe"] = $PS["Data.String.Unsafe"] || {};
  var exports = $PS["Data.String.Unsafe"];
  var $foreign = $PS["Data.String.Unsafe"];
  exports["charAt"] = $foreign.charAt;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.CodePoints"] = $PS["Data.String.CodePoints"] || {};
  var exports = $PS["Data.String.CodePoints"];
  var $foreign = $PS["Data.String.CodePoints"];
  var Data_Array = $PS["Data.Array"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Enum = $PS["Data.Enum"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Unsafe = $PS["Data.String.Unsafe"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var unsurrogate = function (lead) {
      return function (trail) {
          return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
      };
  };
  var isTrail = function (cu) {
      return 56320 <= cu && cu <= 57343;
  };
  var isLead = function (cu) {
      return 55296 <= cu && cu <= 56319;
  };
  var uncons = function (s) {
      var v = Data_String_CodeUnits.length(s);
      if (v === 0) {
          return Data_Maybe.Nothing.value;
      };
      if (v === 1) {
          return new Data_Maybe.Just({
              head: Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s)),
              tail: ""
          });
      };
      var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));
      var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));
      var $21 = isLead(cu0) && isTrail(cu1);
      if ($21) {
          return new Data_Maybe.Just({
              head: unsurrogate(cu0)(cu1),
              tail: Data_String_CodeUnits.drop(2)(s)
          });
      };
      return new Data_Maybe.Just({
          head: cu0,
          tail: Data_String_CodeUnits.drop(1)(s)
      });
  };
  var unconsButWithTuple = function (s) {
      return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
          return new Data_Tuple.Tuple(v.head, v.tail);
      })(uncons(s));
  };
  var toCodePointArrayFallback = function (s) {
      return Data_Unfoldable.unfoldr(Data_Unfoldable.unfoldableArray)(unconsButWithTuple)(s);
  };
  var unsafeCodePointAt0Fallback = function (s) {
      var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));
      var $25 = isLead(cu0) && Data_String_CodeUnits.length(s) > 1;
      if ($25) {
          var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));
          var $26 = isTrail(cu1);
          if ($26) {
              return unsurrogate(cu0)(cu1);
          };
          return cu0;
      };
      return cu0;
  };
  var unsafeCodePointAt0 = $foreign["_unsafeCodePointAt0"](unsafeCodePointAt0Fallback);
  var toCodePointArray = $foreign["_toCodePointArray"](toCodePointArrayFallback)(unsafeCodePointAt0);
  var length = function ($52) {
      return Data_Array.length(toCodePointArray($52));
  };
  var fromCharCode = (function () {
      var $53 = Data_Enum.toEnumWithDefaults(Data_Enum.boundedEnumChar)(Data_Bounded.bottom(Data_Bounded.boundedChar))(Data_Bounded.top(Data_Bounded.boundedChar));
      return function ($54) {
          return Data_String_CodeUnits.singleton($53($54));
      };
  })();
  var singletonFallback = function (v) {
      if (v <= 65535) {
          return fromCharCode(v);
      };
      var lead = Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 55296 | 0;
      var trail = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 56320 | 0;
      return fromCharCode(lead) + fromCharCode(trail);
  };                                                                          
  var singleton = $foreign["_singleton"](singletonFallback);
  var takeFallback = function (n) {
      return function (v) {
          if (n < 1) {
              return "";
          };
          var v1 = uncons(v);
          if (v1 instanceof Data_Maybe.Just) {
              return singleton(v1.value0.head) + takeFallback(n - 1 | 0)(v1.value0.tail);
          };
          return v;
      };
  };
  var take = $foreign["_take"](takeFallback);
  var drop = function (n) {
      return function (s) {
          return Data_String_CodeUnits.drop(Data_String_CodeUnits.length(take(n)(s)))(s);
      };
  };
  exports["length"] = length;
  exports["take"] = take;
})(PS);
(function(exports) {
  "use strict";

  exports.split = function (sep) {
    return function (s) {
      return s.split(sep);
    };
  };

  exports.trim = function (s) {
    return s.trim();
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.Common"] = $PS["Data.String.Common"] || {};
  var exports = $PS["Data.String.Common"];
  var $foreign = $PS["Data.String.Common"];
  exports["split"] = $foreign.split;
  exports["trim"] = $foreign.trim;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.Pattern"] = $PS["Data.String.Pattern"] || {};
  var exports = $PS["Data.String.Pattern"];
  var Pattern = function (x) {
      return x;
  };
  exports["Pattern"] = Pattern;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Symbol"] = $PS["Data.Symbol"] || {};
  var exports = $PS["Data.Symbol"];
  var reflectSymbol = function (dict) {
      return dict.reflectSymbol;
  };
  exports["reflectSymbol"] = reflectSymbol;
})(PS);
(function(exports) {
  "use strict";

  exports.unsafeGet = function (label) {
    return function (rec) {
      return rec[label];
    };
  };

  exports.unsafeSet = function (label) {
    return function (value) {
      return function (rec) {
        var copy = {};
        for (var key in rec) {
          if ({}.hasOwnProperty.call(rec, key)) {
            copy[key] = rec[key];
          }
        }
        copy[label] = value;
        return copy;
      };
    };
  };
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Record.Unsafe"] = $PS["Record.Unsafe"] || {};
  var exports = $PS["Record.Unsafe"];
  var $foreign = $PS["Record.Unsafe"];
  exports["unsafeGet"] = $foreign.unsafeGet;
  exports["unsafeSet"] = $foreign.unsafeSet;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Record"] = $PS["Record"] || {};
  var exports = $PS["Record"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Record_Unsafe = $PS["Record.Unsafe"];
  var insert = function (dictIsSymbol) {
      return function () {
          return function () {
              return function (l) {
                  return function (a) {
                      return function (r) {
                          return Record_Unsafe.unsafeSet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(a)(r);
                      };
                  };
              };
          };
      };
  };
  var get = function (dictIsSymbol) {
      return function () {
          return function (l) {
              return function (r) {
                  return Record_Unsafe.unsafeGet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(r);
              };
          };
      };
  };
  exports["get"] = get;
  exports["insert"] = insert;
})(PS);
(function(exports) {
  "use strict";

  exports.copyRecord = function(rec) {
    var copy = {};
    for (var key in rec) {
      if ({}.hasOwnProperty.call(rec, key)) {
        copy[key] = rec[key];
      }
    }
    return copy;
  };

  exports.unsafeInsert = function(l) {
    return function(a) {
      return function(rec) {
        rec[l] = a;
        return rec;
      };
    };
  };
})(PS["Record.Builder"] = PS["Record.Builder"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Record.Builder"] = $PS["Record.Builder"] || {};
  var exports = $PS["Record.Builder"];
  var $foreign = $PS["Record.Builder"];
  var Control_Category = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Data_Function = $PS["Data.Function"];
  var Data_Symbol = $PS["Data.Symbol"];
  var semigroupoidBuilder = Control_Semigroupoid.semigroupoidFn;
  var insert = function () {
      return function () {
          return function (dictIsSymbol) {
              return function (l) {
                  return function (a) {
                      return function (r1) {
                          return $foreign.unsafeInsert(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(a)(r1);
                      };
                  };
              };
          };
      };
  };
  var categoryBuilder = Control_Category.categoryFn;
  var build = function (v) {
      return function (r1) {
          return v($foreign.copyRecord(r1));
      };
  };
  var buildFromScratch = Data_Function.flip(build)({});
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return build(f(a))(b);
          };
      };
  };
  exports["buildFromScratch"] = buildFromScratch;
  exports["insert"] = insert;
  exports["semigroupoidBuilder"] = semigroupoidBuilder;
  exports["categoryBuilder"] = categoryBuilder;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Type.Proxy"] = $PS["Type.Proxy"] || {};
  var exports = $PS["Type.Proxy"];
  var $$Proxy = (function () {
      function $$Proxy() {

      };
      $$Proxy.value = new $$Proxy();
      return $$Proxy;
  })();
  exports["Proxy"] = $$Proxy;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["ArgParse.Basic"] = $PS["ArgParse.Basic"] || {};
  var exports = $PS["ArgParse.Basic"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Data_Array = $PS["Data.Array"];
  var Data_Array_NonEmpty = $PS["Data.Array.NonEmpty"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_List = $PS["Data.List"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Ring = $PS["Data.Ring"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_String_CodePoints = $PS["Data.String.CodePoints"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_String_Pattern = $PS["Data.String.Pattern"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unit = $PS["Data.Unit"];
  var Record = $PS["Record"];
  var Record_Builder = $PS["Record.Builder"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var Paras = (function () {
      function Paras(value0) {
          this.value0 = value0;
      };
      Paras.create = function (value0) {
          return new Paras(value0);
      };
      return Paras;
  })();
  var Lines = (function () {
      function Lines(value0) {
          this.value0 = value0;
      };
      Lines.create = function (value0) {
          return new Lines(value0);
      };
      return Lines;
  })();
  var Table = (function () {
      function Table(value0) {
          this.value0 = value0;
      };
      Table.create = function (value0) {
          return new Table(value0);
      };
      return Table;
  })();
  var Indent = (function () {
      function Indent(value0) {
          this.value0 = value0;
      };
      Indent.create = function (value0) {
          return new Indent(value0);
      };
      return Indent;
  })();
  var Text = (function () {
      function Text(value0) {
          this.value0 = value0;
      };
      Text.create = function (value0) {
          return new Text(value0);
      };
      return Text;
  })();
  var IsFlag = (function () {
      function IsFlag(value0) {
          this.value0 = value0;
      };
      IsFlag.create = function (value0) {
          return new IsFlag(value0);
      };
      return IsFlag;
  })();
  var IsAny = (function () {
      function IsAny(value0) {
          this.value0 = value0;
      };
      IsAny.create = function (value0) {
          return new IsAny(value0);
      };
      return IsAny;
  })();
  var IsCommand = (function () {
      function IsCommand(value0) {
          this.value0 = value0;
      };
      IsCommand.create = function (value0) {
          return new IsCommand(value0);
      };
      return IsCommand;
  })();
  var HelpFlag = (function () {
      function HelpFlag(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      HelpFlag.create = function (value0) {
          return function (value1) {
              return new HelpFlag(value0, value1);
          };
      };
      return HelpFlag;
  })();
  var HelpAny = (function () {
      function HelpAny(value0) {
          this.value0 = value0;
      };
      HelpAny.create = function (value0) {
          return new HelpAny(value0);
      };
      return HelpAny;
  })();
  var HelpFormat = (function () {
      function HelpFormat(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      HelpFormat.create = function (value0) {
          return function (value1) {
              return new HelpFormat(value0, value1);
          };
      };
      return HelpFormat;
  })();
  var HelpArgs = (function () {
      function HelpArgs(value0) {
          this.value0 = value0;
      };
      HelpArgs.create = function (value0) {
          return new HelpArgs(value0);
      };
      return HelpArgs;
  })();
  var HelpChoose = (function () {
      function HelpChoose(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      HelpChoose.create = function (value0) {
          return function (value1) {
              return new HelpChoose(value0, value1);
          };
      };
      return HelpChoose;
  })();
  var HelpCommand = (function () {
      function HelpCommand(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      HelpCommand.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new HelpCommand(value0, value1, value2);
              };
          };
      };
      return HelpCommand;
  })();
  var HelpRest = (function () {
      function HelpRest(value0) {
          this.value0 = value0;
      };
      HelpRest.create = function (value0) {
          return new HelpRest(value0);
      };
      return HelpRest;
  })();
  var ExpectedFlag = (function () {
      function ExpectedFlag() {

      };
      ExpectedFlag.value = new ExpectedFlag();
      return ExpectedFlag;
  })();
  var ExpectedArgValue = (function () {
      function ExpectedArgValue() {

      };
      ExpectedArgValue.value = new ExpectedArgValue();
      return ExpectedArgValue;
  })();
  var ExpectedRest = (function () {
      function ExpectedRest() {

      };
      ExpectedRest.value = new ExpectedRest();
      return ExpectedRest;
  })();
  var ExpectedArg = (function () {
      function ExpectedArg() {

      };
      ExpectedArg.value = new ExpectedArg();
      return ExpectedArg;
  })();
  var DuplicateArg = (function () {
      function DuplicateArg() {

      };
      DuplicateArg.value = new DuplicateArg();
      return DuplicateArg;
  })();
  var UnformatFailed = (function () {
      function UnformatFailed(value0) {
          this.value0 = value0;
      };
      UnformatFailed.create = function (value0) {
          return new UnformatFailed(value0);
      };
      return UnformatFailed;
  })();
  var UnknownArg = (function () {
      function UnknownArg(value0) {
          this.value0 = value0;
      };
      UnknownArg.create = function (value0) {
          return new UnknownArg(value0);
      };
      return UnknownArg;
  })();
  var ShowHelp = (function () {
      function ShowHelp() {

      };
      ShowHelp.value = new ShowHelp();
      return ShowHelp;
  })();
  var ShowInfo = (function () {
      function ShowInfo(value0) {
          this.value0 = value0;
      };
      ShowInfo.create = function (value0) {
          return new ShowInfo(value0);
      };
      return ShowInfo;
  })();
  var ArgError = (function () {
      function ArgError(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ArgError.create = function (value0) {
          return function (value1) {
              return new ArgError(value0, value1);
          };
      };
      return ArgError;
  })();
  var ArgHalt = (function () {
      function ArgHalt(value0) {
          this.value0 = value0;
      };
      ArgHalt.create = function (value0) {
          return new ArgHalt(value0);
      };
      return ArgHalt;
  })();
  var ArgMatch = (function () {
      function ArgMatch(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ArgMatch.create = function (value0) {
          return function (value1) {
              return new ArgMatch(value0, value1);
          };
      };
      return ArgMatch;
  })();
  var ArgFail = (function () {
      function ArgFail() {

      };
      ArgFail.value = new ArgFail();
      return ArgFail;
  })();
  var ArgParser = (function () {
      function ArgParser(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ArgParser.create = function (value0) {
          return function (value1) {
              return new ArgParser(value0, value1);
          };
      };
      return ArgParser;
  })();
  var unformat = function (doc) {
      return function (unf) {
          return function (v) {
              var help = new HelpFormat(doc, v.value0);
              var go = function (v1) {
                  var step = function (stk) {
                      return function (args) {
                          var v2 = v1.step(stk)(args);
                          if (v2 instanceof ArgHalt && v2.value0.value0 instanceof Data_List_Types.Cons) {
                              return new ArgHalt(new ArgError(new Data_List_Types.Cons(help, v2.value0.value0.value1), v2.value0.value1));
                          };
                          if (v2 instanceof ArgHalt) {
                              return new ArgHalt(v2.value0);
                          };
                          if (v2 instanceof ArgMatch) {
                              return new ArgMatch(go(v2.value0), v2.value1);
                          };
                          if (v2 instanceof ArgFail) {
                              return ArgFail.value;
                          };
                          throw new Error("Failed pattern match at ArgParse.Basic (line 266, column 7 - line 271, column 27): " + [ v2.constructor.name ]);
                      };
                  };
                  var done = function (stk) {
                      return Control_Bind.bind(Data_Either.bindEither)(v1.done(new Data_List_Types.Cons(help, stk)))(function (value) {
                          return Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)((function () {
                              var $388 = ArgError.create(new Data_List_Types.Cons(help, stk));
                              return function ($389) {
                                  return $388(UnformatFailed.create($389));
                              };
                          })())(unf(value));
                      });
                  };
                  return {
                      step: step,
                      done: done,
                      saturated: v1.saturated
                  };
              };
              return new ArgParser(help, go(v.value1));
          };
      };
  };
  var semigroupHelp = {
      append: function (v) {
          return function (v1) {
              if (v instanceof HelpArgs && v1 instanceof HelpArgs) {
                  return new HelpArgs(Data_Semigroup.append(Data_Semigroup.semigroupArray)(v.value0)(v1.value0));
              };
              if (v instanceof HelpArgs) {
                  return new HelpArgs(Data_Array.snoc(v.value0)(v1));
              };
              if (v1 instanceof HelpArgs) {
                  return new HelpArgs(Data_Array.cons(v)(v1.value0));
              };
              return new HelpArgs([ v, v1 ]);
          };
      }
  };
  var printHelpTable$prime = function (stk) {
      return function (v) {
          if (v instanceof HelpFlag) {
              var names = Data_Array.intercalate(Data_Monoid.monoidString)(",")(v.value0);
              if (stk instanceof Data_List_Types.Cons && stk.value0 instanceof HelpFormat) {
                  return [ new Data_Tuple.Tuple(new IsFlag(v.value0), [ new Text(names + (" " + stk.value0.value0)), new Text(v.value1) ]) ];
              };
              return [ new Data_Tuple.Tuple(new IsFlag(v.value0), [ new Text(names), new Text(v.value1) ]) ];
          };
          if (v instanceof HelpAny) {
              if (stk instanceof Data_List_Types.Cons && stk.value0 instanceof HelpFormat) {
                  return [ new Data_Tuple.Tuple(new IsAny(stk.value0.value0), [ new Text(stk.value0.value0), new Text(v.value0) ]) ];
              };
              return [ new Data_Tuple.Tuple(new IsAny("ANY"), [ new Text("ANY"), new Text(v.value0) ]) ];
          };
          if (v instanceof HelpRest) {
              return [ new Data_Tuple.Tuple(new IsAny("--"), [ new Text("--"), new Text(v.value0) ]) ];
          };
          if (v instanceof HelpCommand) {
              return [ new Data_Tuple.Tuple(new IsCommand(v.value0), [ new Text(Data_Array.intercalate(Data_Monoid.monoidString)(",")(v.value0)), new Text(v.value1) ]) ];
          };
          if (v instanceof HelpFormat) {
              return printHelpTable$prime(new Data_List_Types.Cons(new HelpFormat(v.value0, v.value1), stk))(v.value1);
          };
          if (v instanceof HelpChoose) {
              return Control_Bind.bindFlipped(Control_Bind.bindArray)(printHelpTable$prime(stk))(v.value1);
          };
          if (v instanceof HelpArgs) {
              return Control_Bind.bindFlipped(Control_Bind.bindArray)(printHelpTable$prime(stk))(v.value0);
          };
          throw new Error("Failed pattern match at ArgParse.Basic (line 744, column 23 - line 767, column 33): " + [ v.constructor.name ]);
      };
  };
  var parserHelp = function (v) {
      return v.value0;
  };
  var parseArgs$prime = function ($copy_v) {
      return function ($copy_stk) {
          return function ($copy_args) {
              var $tco_var_v = $copy_v;
              var $tco_var_stk = $copy_stk;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v, stk, args) {
                  var v1 = v.step(stk)(args);
                  if (v1 instanceof ArgHalt) {
                      $tco_done = true;
                      return new Data_Either.Left(v1.value0);
                  };
                  if (v1 instanceof ArgMatch) {
                      $tco_var_v = v1.value0;
                      $tco_var_stk = stk;
                      $copy_args = v1.value1;
                      return;
                  };
                  if (v1 instanceof ArgFail) {
                      if (args instanceof Data_List_Types.Nil) {
                          $tco_done = true;
                          return v.done(stk);
                      };
                      if (args instanceof Data_List_Types.Cons) {
                          $tco_done = true;
                          return new Data_Either.Left(new ArgError(stk, new UnknownArg(args.value0)));
                      };
                      throw new Error("Failed pattern match at ArgParse.Basic (line 623, column 7 - line 627, column 47): " + [ args.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at ArgParse.Basic (line 617, column 3 - line 627, column 47): " + [ v1.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_v, $tco_var_stk, $copy_args);
              };
              return $tco_result;
          };
      };
  };
  var parseArgs = function (dictFoldable) {
      return function (cmd) {
          return function (doc) {
              return function (v) {
                  var $392 = parseArgs$prime(v.value1)(Control_Applicative.pure(Data_List_Types.applicativeList)(new HelpCommand([ cmd ], doc, v.value0)));
                  var $393 = Data_List.fromFoldable(dictFoldable);
                  return function ($394) {
                      return $392($393($394));
                  };
              };
          };
      };
  };    
  var joinColumns = function (width) {
      return function (sep) {
          return function (leftLines) {
              return function (rightLines) {
                  var go = function (left) {
                      return function (right) {
                          var len = Data_String_CodePoints.length(left);
                          var $170 = len < width;
                          if ($170) {
                              return left + (Data_Monoid.power(Data_Monoid.monoidString)(" ")(width - len | 0) + (sep + right));
                          };
                          var $171 = len > width;
                          if ($171) {
                              return Data_String_CodePoints.take(width)(left) + (sep + right);
                          };
                          return left + (sep + right);
                      };
                  };
                  var diff = Data_Array.length(leftLines) - Data_Array.length(rightLines) | 0;
                  var $172 = diff < 0;
                  if ($172) {
                      return Data_Array.zipWith(go)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(leftLines)(Data_Array.replicate(Data_Ord.abs(Data_Ord.ordInt)(Data_Ring.ringInt)(diff))("")))(rightLines);
                  };
                  return Data_Array.zipWith(go)(leftLines)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(rightLines)(Data_Array.replicate(diff)("")));
              };
          };
      };
  };
  var renderDocLines = function (ind) {
      return function (v) {
          if (v instanceof Paras) {
              return Control_Bind.join(Control_Bind.bindArray)(Data_Array.intersperse([ "" ])(Data_Array.filter((function () {
                  var $397 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
                  return function ($398) {
                      return $397(Data_Array["null"]($398));
                  };
              })())(Data_Functor.map(Data_Functor.functorArray)(renderDocLines(ind))(v.value0))));
          };
          if (v instanceof Lines) {
              return Control_Bind.bindFlipped(Control_Bind.bindArray)(renderDocLines(ind))(v.value0);
          };
          if (v instanceof Text) {
              return Data_Functor.map(Data_Functor.functorArray)(Data_Semigroup.append(Data_Semigroup.semigroupString)(ind))(Data_String_Common.split("\x0a")(v.value0));
          };
          if (v instanceof Indent) {
              return renderDocLines(ind + "    ")(v.value0);
          };
          if (v instanceof Table) {
              return printTableLines(ind)(v.value0);
          };
          throw new Error("Failed pattern match at ArgParse.Basic (line 780, column 22 - line 790, column 30): " + [ v.constructor.name ]);
      };
  };
  var printTableLines = function (ind) {
      return function (rows) {
          var rows$prime = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Functor.functorArray)(renderDocLines("")))(rows);
          var numCols = Data_Foldable.foldr(Data_Foldable.foldableArray)((function () {
              var $399 = Data_Ord.max(Data_Ord.ordInt);
              return function ($400) {
                  return $399(Data_Array.length($400));
              };
          })())(0)(rows);
          var ixs = Data_Array.range(0)(numCols - 1 | 0);
          var colWidths = Data_Functor.map(Data_Functor.functorArray)(function (ix) {
              return Data_Foldable.foldr(Data_Foldable.foldableArray)((function () {
                  var $401 = Data_Ord.max(Data_Ord.ordInt);
                  var $402 = Data_Foldable.foldr(Data_Foldable.foldableArray)((function () {
                      var $406 = Data_Ord.max(Data_Ord.ordInt);
                      return function ($407) {
                          return $406(Data_String_CodePoints.length($407));
                      };
                  })())(0);
                  var $403 = Data_Maybe.fromMaybe([  ]);
                  var $404 = Data_Function.flip(Data_Array.index)(ix);
                  return function ($405) {
                      return $401($402($403($404($405))));
                  };
              })())(0)(rows$prime);
          })(ixs);
          return Control_Bind.bind(Control_Bind.bindArray)(rows$prime)(function (cols) {
              var v = Data_Array_NonEmpty.fromArray(Data_Array.zip(colWidths)(cols));
              if (v instanceof Data_Maybe.Nothing) {
                  return [  ];
              };
              if (v instanceof Data_Maybe.Just) {
                  return Data_Functor.map(Data_Functor.functorArray)(Data_Semigroup.append(Data_Semigroup.semigroupString)(ind))(Data_Tuple.snd(Data_Array_NonEmpty.foldr1(function (v1) {
                      return function (v2) {
                          return new Data_Tuple.Tuple(v1.value0 + v2.value0 | 0, joinColumns(v1.value0)("    ")(v1.value1)(v2.value1));
                      };
                  })(v.value0)));
              };
              throw new Error("Failed pattern match at ArgParse.Basic (line 826, column 3 - line 834, column 27): " + [ v.constructor.name ]);
          });
      };
  };
  var renderDoc = (function () {
      var $408 = Data_Array.intercalate(Data_Monoid.monoidString)("\x0a");
      var $409 = renderDocLines("");
      return function ($410) {
          return $408($409($410));
      };
  })(); 
  var functorArgResult = {
      map: function (f) {
          return function (m) {
              if (m instanceof ArgHalt) {
                  return new ArgHalt(m.value0);
              };
              if (m instanceof ArgMatch) {
                  return new ArgMatch(f(m.value0), m.value1);
              };
              if (m instanceof ArgFail) {
                  return ArgFail.value;
              };
              throw new Error("Failed pattern match at ArgParse.Basic (line 131, column 1 - line 131, column 54): " + [ m.constructor.name ]);
          };
      }
  };
  var functorArgFold = {
      map: function (f) {
          return function (m) {
              return {
                  done: Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(Data_Either.functorEither)(f))(m.done),
                  step: Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(functorArgResult)(Data_Functor.map(functorArgFold)(f))))(m.step),
                  saturated: m.saturated
              };
          };
      }
  };
  var functorArgParser = {
      map: function (f) {
          return function (m) {
              return new ArgParser(m.value0, Data_Functor.map(functorArgFold)(f)(m.value1));
          };
      }
  };
  var flag$prime = function (names) {
      var go = function (v) {
          if (v instanceof Data_List_Types.Cons && Data_Array.elem(Data_Eq.eqString)(v.value0)(names)) {
              return new ArgMatch(Data_Unit.unit, v.value1);
          };
          return ArgFail.value;
      };
      return go;
  };
  var flagHelp = (function () {
      var name = [ "--help", "-h" ];
      var step = function (stk) {
          return function (args) {
              var v = flag$prime(name)(args);
              if (v instanceof ArgHalt) {
                  return new ArgHalt(v.value0);
              };
              if (v instanceof ArgFail) {
                  return ArgFail.value;
              };
              if (v instanceof ArgMatch) {
                  return new ArgHalt(new ArgError(stk, ShowHelp.value));
              };
              throw new Error("Failed pattern match at ArgParse.Basic (line 460, column 5 - line 463, column 54): " + [ v.constructor.name ]);
          };
      };
      var help = new HelpFlag(name, "Show this help message.");
      var done = Data_Function["const"](new Data_Either.Right(Data_Unit.unit));
      return new ArgParser(help, {
          step: step,
          done: done,
          saturated: true
      });
  })();
  var failDup = function (help) {
      return function (errMsg) {
          return function (v) {
              var step = function (stk) {
                  return function (args) {
                      var v1 = v.step(stk)(args);
                      if (v1 instanceof ArgHalt) {
                          return new ArgHalt(v1.value0);
                      };
                      if (v1 instanceof ArgFail) {
                          return ArgFail.value;
                      };
                      if (v1 instanceof ArgMatch) {
                          return new ArgHalt(new ArgError(new Data_List_Types.Cons(help, stk), errMsg));
                      };
                      throw new Error("Failed pattern match at ArgParse.Basic (line 195, column 5 - line 198, column 61): " + [ v1.constructor.name ]);
                  };
              };
              return {
                  step: step,
                  done: v.done,
                  saturated: true
              };
          };
      };
  };
  var flag = function (name) {
      return function (doc) {
          var help = new HelpFlag(name, doc);
          var step = function (v) {
              var $415 = Data_Functor.map(functorArgResult)(function (value) {
                  return failDup(help)(DuplicateArg.value)({
                      step: step,
                      done: Data_Function["const"](new Data_Either.Right(value)),
                      saturated: true
                  });
              });
              var $416 = flag$prime(name);
              return function ($417) {
                  return $415($416($417));
              };
          };
          var done = function (stk) {
              return new Data_Either.Left(new ArgError(new Data_List_Types.Cons(help, stk), ExpectedFlag.value));
          };
          return new ArgParser(help, {
              step: step,
              done: done,
              saturated: false
          });
      };
  };
  var eqHelpClass = {
      eq: function (x) {
          return function (y) {
              if (x instanceof IsFlag && y instanceof IsFlag) {
                  return Data_Eq.eq(Data_Eq.eqArray(Data_Eq.eqString))(x.value0)(y.value0);
              };
              if (x instanceof IsAny && y instanceof IsAny) {
                  return x.value0 === y.value0;
              };
              if (x instanceof IsCommand && y instanceof IsCommand) {
                  return Data_Eq.eq(Data_Eq.eqArray(Data_Eq.eqString))(x.value0)(y.value0);
              };
              return false;
          };
      }
  };
  var ordHelpClass = {
      compare: function (x) {
          return function (y) {
              if (x instanceof IsFlag && y instanceof IsFlag) {
                  return Data_Ord.compare(Data_Ord.ordArray(Data_Ord.ordString))(x.value0)(y.value0);
              };
              if (x instanceof IsFlag) {
                  return Data_Ordering.LT.value;
              };
              if (y instanceof IsFlag) {
                  return Data_Ordering.GT.value;
              };
              if (x instanceof IsAny && y instanceof IsAny) {
                  return Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);
              };
              if (x instanceof IsAny) {
                  return Data_Ordering.LT.value;
              };
              if (y instanceof IsAny) {
                  return Data_Ordering.GT.value;
              };
              if (x instanceof IsCommand && y instanceof IsCommand) {
                  return Data_Ord.compare(Data_Ord.ordArray(Data_Ord.ordString))(x.value0)(y.value0);
              };
              throw new Error("Failed pattern match at ArgParse.Basic (line 726, column 1 - line 726, column 46): " + [ x.constructor.name, y.constructor.name ]);
          };
      },
      Eq0: function () {
          return eqHelpClass;
      }
  };
  var printHelpTable = function (stk) {
      var groupFn = function (v) {
          return function (v1) {
              if (v instanceof IsFlag && v1 instanceof IsFlag) {
                  return true;
              };
              if (v instanceof IsAny && v1 instanceof IsAny) {
                  return true;
              };
              if (v instanceof IsCommand && v1 instanceof IsCommand) {
                  return true;
              };
              return false;
          };
      };
      var $431 = Data_Array.intercalate(Data_Monoid.monoidArray)([ [ new Text("") ] ]);
      var $432 = Data_Functor.map(Data_Functor.functorArray)((function () {
          var $437 = Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.snd);
          return function ($438) {
              return $437(Data_Array_NonEmpty.toArray($438));
          };
      })());
      var $433 = Data_Array.groupBy(Data_Function.on(groupFn)(Data_Tuple.fst));
      var $434 = Data_Array.sortBy(Data_Ord.comparing(ordHelpClass)(Data_Tuple.fst));
      var $435 = printHelpTable$prime(stk);
      return function ($436) {
          return $431($432($433($434($435($436)))));
      };
  };
  var printHelp$prime = function (stk) {
      return function (v) {
          if (v instanceof HelpFormat) {
              return printHelp$prime(new Data_List_Types.Cons(new HelpFormat(v.value0, v.value1), stk))(v.value1);
          };
          if (v instanceof HelpCommand) {
              return new Paras([ new Lines([ new Text(Data_Array.intercalate(Data_Monoid.monoidString)(",")(v.value0)), new Indent(new Text(v.value1)) ]), new Indent(printHelp$prime(stk)(v.value2)) ]);
          };
          return new Table(printHelpTable(stk)(v));
      };
  };
  var printArgError = function (v) {
      var getCmd = function ($copy_cmd) {
          return function ($copy_desc) {
              return function ($copy_help) {
                  return function ($copy_v1) {
                      var $tco_var_cmd = $copy_cmd;
                      var $tco_var_desc = $copy_desc;
                      var $tco_var_help = $copy_help;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(cmd, desc, help, v1) {
                          if (v1 instanceof Data_List_Types.Nil) {
                              $tco_done = true;
                              return {
                                  cmd: cmd,
                                  desc: desc,
                                  help: help
                              };
                          };
                          if (v1 instanceof Data_List_Types.Cons && v1.value0 instanceof HelpCommand) {
                              $tco_var_cmd = new Data_List_Types.Cons(v1.value0.value0, cmd);
                              $tco_var_desc = Control_Alt.alt(Data_Maybe.altMaybe)(desc)(new Data_Maybe.Just(v1.value0.value1));
                              $tco_var_help = Control_Alt.alt(Data_Maybe.altMaybe)(help)(new Data_Maybe.Just(v1.value0.value2));
                              $copy_v1 = v1.value1;
                              return;
                          };
                          if (v1 instanceof Data_List_Types.Cons && v1.value0 instanceof HelpFlag) {
                              $tco_var_cmd = new Data_List_Types.Cons(v1.value0.value0, cmd);
                              $tco_var_desc = Data_Maybe.Nothing.value;
                              $tco_var_help = new Data_Maybe.Just(new HelpFlag(v1.value0.value0, v1.value0.value1));
                              $copy_v1 = v1.value1;
                              return;
                          };
                          if (v1 instanceof Data_List_Types.Cons && v1.value0 instanceof HelpAny) {
                              $tco_var_cmd = cmd;
                              $tco_var_desc = Data_Maybe.Nothing.value;
                              $tco_var_help = new Data_Maybe.Just(new HelpAny(v1.value0.value0));
                              $copy_v1 = v1.value1;
                              return;
                          };
                          if (v1 instanceof Data_List_Types.Cons && v1.value0 instanceof HelpFormat) {
                              $tco_var_cmd = cmd;
                              $tco_var_desc = desc;
                              $tco_var_help = help;
                              $copy_v1 = new Data_List_Types.Cons(v1.value0.value1, v1.value1);
                              return;
                          };
                          if (v1 instanceof Data_List_Types.Cons) {
                              $tco_var_cmd = cmd;
                              $tco_var_desc = desc;
                              $tco_var_help = help;
                              $copy_v1 = v1.value1;
                              return;
                          };
                          throw new Error("Failed pattern match at ArgParse.Basic (line 671, column 26 - line 682, column 30): " + [ v1.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_cmd, $tco_var_desc, $tco_var_help, $copy_v1);
                      };
                      return $tco_result;
                  };
              };
          };
      };
      var printArgError$prime = function (err) {
          var v1 = getCmd(Data_List_Types.Nil.value)(Data_Maybe.Nothing.value)(Data_Maybe.Nothing.value)(v.value0);
          return new Lines([ new Text(Data_Foldable.intercalate(Data_List_Types.foldableList)(Data_Monoid.monoidString)(" ")(Data_Functor.map(Data_List_Types.functorList)(Data_Array.intercalate(Data_Monoid.monoidString)(","))(v1.cmd))), new Indent(new Paras([ err, Data_Maybe.maybe(new Lines([  ]))(Text.create)(v1.desc), Data_Maybe.maybe(new Lines([  ]))(printHelp$prime(v.value0))(v1.help) ])) ]);
      };
      return renderDoc((function () {
          if (v.value1 instanceof ExpectedFlag) {
              return printArgError$prime(new Text("Expected flag."));
          };
          if (v.value1 instanceof ExpectedArgValue) {
              if (v.value0 instanceof Data_List_Types.Cons && v.value0.value0 instanceof HelpFormat) {
                  return printArgError$prime(new Text("Expected " + (v.value0.value0.value0 + ".")));
              };
              return printArgError$prime(new Text("Expected argument value."));
          };
          if (v.value1 instanceof ExpectedArg) {
              if (v.value0 instanceof Data_List_Types.Cons && v.value0.value0 instanceof HelpFormat) {
                  return printArgError$prime(new Text("Expected " + (v.value0.value0.value0 + ".")));
              };
              if (v.value0 instanceof Data_List_Types.Cons && v.value0.value0 instanceof HelpChoose) {
                  return printArgError$prime(new Text("Expected " + (v.value0.value0.value0 + ".")));
              };
              return printArgError$prime(new Text("Expected argument."));
          };
          if (v.value1 instanceof ExpectedRest) {
              return printArgError$prime(new Text("Expected rest arguments."));
          };
          if (v.value1 instanceof DuplicateArg) {
              if (v.value0 instanceof Data_List_Types.Cons && v.value0.value0 instanceof HelpChoose) {
                  return printArgError$prime(new Text("Duplicate " + (v.value0.value0.value0 + ".")));
              };
              return printArgError$prime(new Text("Duplicate argument."));
          };
          if (v.value1 instanceof UnformatFailed) {
              return printArgError$prime(new Text(v.value1.value0));
          };
          if (v.value1 instanceof ShowHelp) {
              return printArgError$prime(new Lines([  ]));
          };
          if (v.value1 instanceof ShowInfo) {
              return new Text(v.value1.value0);
          };
          if (v.value1 instanceof UnknownArg) {
              return printArgError$prime(new Lines([ new Text("Unexpected argument:"), new Indent(new Text(v.value1.value0)) ]));
          };
          throw new Error("Failed pattern match at ArgParse.Basic (line 633, column 13 - line 668, column 10): " + [ v.value1.constructor.name ]);
      })());
  };   
  var $$default = function (value) {
      return function (v) {
          return new ArgParser(v.value0, {
              step: v.value1.step,
              done: (function () {
                  var $441 = Data_Either.either(Data_Function["const"](new Data_Either.Right(value)))(Data_Either.Right.create);
                  return function ($442) {
                      return $441(v.value1.done($442));
                  };
              })(),
              saturated: true
          });
      };
  };   
  var choose = function (name) {
      return function (parsers) {
          var help = new HelpChoose(name, Data_Functor.map(Data_Functor.functorArray)(parserHelp)(parsers));
          var go2 = function (stk) {
              return function (args) {
                  return function (acc) {
                      return function (v) {
                          if (v instanceof Data_List_Types.Cons) {
                              var v1 = v.value0.step(stk)(args);
                              if (v1 instanceof ArgHalt) {
                                  return new ArgHalt(v1.value0);
                              };
                              if (v1 instanceof ArgFail) {
                                  return go2(stk)(args)(new Data_List_Types.Cons(v.value0, acc))(v.value1);
                              };
                              if (v1 instanceof ArgMatch) {
                                  if (v1.value0.saturated) {
                                      return new ArgMatch(failDup(help)(DuplicateArg.value)({
                                          step: go1(Data_Foldable.foldr(Data_List_Types.foldableList)(Data_List_Types.Cons.create)(new Data_List_Types.Cons(v1.value0, v.value1))(acc)),
                                          done: v1.value0.done,
                                          saturated: true
                                      }), v1.value1);
                                  };
                                  return new ArgMatch({
                                      step: function (stk$prime) {
                                          return function (args$prime$prime) {
                                              return go2(stk$prime)(args$prime$prime)(acc)(new Data_List_Types.Cons(v1.value0, v.value1));
                                          };
                                      },
                                      done: v1.value0.done,
                                      saturated: false
                                  }, v1.value1);
                              };
                              throw new Error("Failed pattern match at ArgParse.Basic (line 421, column 7 - line 441, column 20): " + [ v1.constructor.name ]);
                          };
                          if (v instanceof Data_List_Types.Nil) {
                              return ArgFail.value;
                          };
                          throw new Error("Failed pattern match at ArgParse.Basic (line 419, column 22 - line 443, column 14): " + [ v.constructor.name ]);
                      };
                  };
              };
          };
          var go1 = function (parsers$prime) {
              return function (stk) {
                  return function (args) {
                      return go2(stk)(args)(Data_List_Types.Nil.value)(parsers$prime);
                  };
              };
          };
          return new ArgParser(help, {
              step: go1(Data_List.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(function (v) {
                  return v.value1;
              })(parsers))),
              done: function (stk) {
                  return new Data_Either.Left(new ArgError(new Data_List_Types.Cons(help, stk), ExpectedArg.value));
              },
              saturated: false
          });
      };
  };
  var buildRecordArgs = function (dict) {
      return dict.buildRecordArgs;
  };
  var fromRecord = function () {
      return function (dictBuildRecordArgs) {
          var $446 = Data_Functor.map(functorArgParser)(Record_Builder.buildFromScratch);
          var $447 = buildRecordArgs(dictBuildRecordArgs)(Type_Proxy["Proxy"].value);
          return function ($448) {
              return $446($447($448));
          };
      };
  };
  var $$boolean = (function () {
      var $449 = $$default(false);
      return function ($450) {
          return $449((function (v) {
              return Data_Functor.voidRight(functorArgParser)(true)(v);
          })($450));
      };
  })();
  var argument$prime = function (stk) {
      return function (names) {
          var matchParam = function (arg) {
              return Data_Array.findMap((function () {
                  var $451 = Data_Function.flip(Data_String_CodeUnits.stripPrefix)(arg);
                  return function ($452) {
                      return $451(Data_String_Pattern.Pattern($452));
                  };
              })())(names);
          };
          var go = function (v) {
              var v1 = function (v2) {
                  return ArgFail.value;
              };
              if (v instanceof Data_List_Types.Cons) {
                  var $341 = matchParam(v.value0);
                  if ($341 instanceof Data_Maybe.Just) {
                      var $342 = Data_String_CodeUnits.take(1)($341.value0) === "=";
                      if ($342) {
                          return new ArgMatch(Data_String_CodeUnits.drop(1)($341.value0), v.value1);
                      };
                      var $343 = $341.value0 === "";
                      if ($343) {
                          if (v.value1 instanceof Data_List_Types.Cons) {
                              return new ArgMatch(v.value1.value0, v.value1.value1);
                          };
                          return new ArgHalt(new ArgError(stk, ExpectedArgValue.value));
                      };
                      return ArgFail.value;
                  };
                  return v1(true);
              };
              return v1(true);
          };
          return go;
      };
  };
  var argument = function (name) {
      return function (doc) {
          var help = new HelpFlag(name, doc);
          var step = function (stk) {
              var $453 = Data_Functor.map(functorArgResult)(function (value) {
                  return failDup(help)(DuplicateArg.value)({
                      step: step,
                      done: Data_Function["const"](new Data_Either.Right(value)),
                      saturated: true
                  });
              });
              var $454 = argument$prime(new Data_List_Types.Cons(help, stk))(name);
              return function ($455) {
                  return $453($454($455));
              };
          };
          var done = function (stk) {
              return new Data_Either.Left(new ArgError(new Data_List_Types.Cons(help, stk), ExpectedArg.value));
          };
          return new ArgParser(help, {
              step: step,
              done: done,
              saturated: false
          });
      };
  };
  var applyArgFold = {
      apply: function (v) {
          return function (v1) {
              var step = function (stk) {
                  return function (args) {
                      var v2 = v.step(stk)(args);
                      if (v2 instanceof ArgHalt) {
                          return new ArgHalt(v2.value0);
                      };
                      if (v2 instanceof ArgMatch) {
                          return new ArgMatch(Control_Apply.apply(applyArgFold)(v2.value0)(v1), v2.value1);
                      };
                      if (v2 instanceof ArgFail) {
                          var v3 = v1.step(stk)(args);
                          if (v3 instanceof ArgHalt) {
                              return new ArgHalt(v3.value0);
                          };
                          if (v3 instanceof ArgMatch) {
                              return new ArgMatch(Control_Apply.apply(applyArgFold)(v)(v3.value0), v3.value1);
                          };
                          if (v3 instanceof ArgFail) {
                              return ArgFail.value;
                          };
                          throw new Error("Failed pattern match at ArgParse.Basic (line 166, column 11 - line 172, column 22): " + [ v3.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at ArgParse.Basic (line 161, column 7 - line 172, column 22): " + [ v2.constructor.name ]);
                  };
              };
              var done = function (stk) {
                  return Control_Apply.apply(Data_Either.applyEither)(v.done(stk))(v1.done(stk));
              };
              return {
                  step: step,
                  done: done,
                  saturated: v.saturated && v1.saturated
              };
          };
      },
      Functor0: function () {
          return functorArgFold;
      }
  };
  var applyParser = {
      apply: function (v) {
          return function (v1) {
              return new ArgParser(Data_Semigroup.append(semigroupHelp)(v.value0)(v1.value0), Control_Apply.apply(applyArgFold)(v.value1)(v1.value1));
          };
      },
      Functor0: function () {
          return functorArgParser;
      }
  };
  var buildArgsCons = function (dictIsSymbol) {
      return function () {
          return function () {
              return function () {
                  return function (dictBuildRecordArgs) {
                      return {
                          buildRecordArgs: function (v) {
                              return function (rs) {
                                  return Control_Apply.apply(applyParser)(Data_Functor.map(functorArgParser)(function (a) {
                                      return function (b) {
                                          return Control_Semigroupoid.composeFlipped(Record_Builder.semigroupoidBuilder)(Record_Builder.insert()()(dictIsSymbol)(Type_Proxy["Proxy"].value)(a))(b);
                                      };
                                  })(Record.get(dictIsSymbol)()(Type_Proxy["Proxy"].value)(rs)))(buildRecordArgs(dictBuildRecordArgs)(Type_Proxy["Proxy"].value)(rs));
                              };
                          }
                      };
                  };
              };
          };
      };
  };
  var applicativeArgFold = {
      pure: function (value) {
          return {
              step: function (v) {
                  return function (v1) {
                      return ArgFail.value;
                  };
              },
              done: Data_Function["const"](new Data_Either.Right(value)),
              saturated: true
          };
      },
      Apply0: function () {
          return applyArgFold;
      }
  };
  var buildRecordArgsNil = {
      buildRecordArgs: function (v) {
          return function (v1) {
              return new ArgParser(new HelpArgs([  ]), Control_Applicative.pure(applicativeArgFold)(Control_Category.identity(Record_Builder.categoryBuilder)));
          };
      }
  };
  var command = function (name) {
      return function (doc) {
          return function (v) {
              var help = new HelpCommand(name, doc, v.value0);
              var go = function (v1) {
                  var step = function (stk) {
                      return function (args) {
                          var v2 = flag$prime(name)(args);
                          if (v2 instanceof ArgHalt) {
                              return new ArgHalt(v2.value0);
                          };
                          if (v2 instanceof ArgFail) {
                              return ArgFail.value;
                          };
                          if (v2 instanceof ArgMatch) {
                              var v3 = parseArgs$prime(v1)(new Data_List_Types.Cons(help, stk))(v2.value1);
                              if (v3 instanceof Data_Either.Left) {
                                  return new ArgHalt(v3.value0);
                              };
                              if (v3 instanceof Data_Either.Right) {
                                  return new ArgMatch(Control_Applicative.pure(applicativeArgFold)(v3.value0), Data_List_Types.Nil.value);
                              };
                              throw new Error("Failed pattern match at ArgParse.Basic (line 553, column 11 - line 557, column 40): " + [ v3.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at ArgParse.Basic (line 549, column 7 - line 557, column 40): " + [ v2.constructor.name ]);
                      };
                  };
                  var extract = function ($456) {
                      return v1.done((function (v2) {
                          return new Data_List_Types.Cons(help, v2);
                      })($456));
                  };
                  return {
                      step: step,
                      done: v1.done,
                      saturated: false
                  };
              };
              return new ArgParser(help, go(v.value1));
          };
      };
  };
  exports["ShowHelp"] = ShowHelp;
  exports["ShowInfo"] = ShowInfo;
  exports["flag"] = flag;
  exports["flagHelp"] = flagHelp;
  exports["argument"] = argument;
  exports["fromRecord"] = fromRecord;
  exports["unformat"] = unformat;
  exports["boolean"] = $$boolean;
  exports["default"] = $$default;
  exports["choose"] = choose;
  exports["command"] = command;
  exports["parseArgs"] = parseArgs;
  exports["printArgError"] = printArgError;
  exports["functorArgParser"] = functorArgParser;
  exports["applyParser"] = applyParser;
  exports["buildRecordArgsNil"] = buildRecordArgsNil;
  exports["buildArgsCons"] = buildArgsCons;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["CLI"] = $PS["CLI"] || {};
  var exports = $PS["CLI"];
  var ArgParse_Basic = $PS["ArgParse.Basic"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Either = $PS["Data.Either"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Monoid = $PS["Data.Monoid"];
  var GenLibraryDeps = (function () {
      function GenLibraryDeps(value0) {
          this.value0 = value0;
      };
      GenLibraryDeps.create = function (value0) {
          return new GenLibraryDeps(value0);
      };
      return GenLibraryDeps;
  })();
  var GenSpagoFiles = (function () {
      function GenSpagoFiles(value0) {
          this.value0 = value0;
      };
      GenSpagoFiles.create = function (value0) {
          return new GenSpagoFiles(value0);
      };
      return GenSpagoFiles;
  })();
  var parser = (function () {
      var inputArg = (function () {
          var desc = Data_Foldable.fold(Data_Foldable.foldableArray)(Data_Monoid.monoidString)([ "The JSON-version of the `packages.dhall` file. Use ", "`dhall-to-json --compact --file ./packages.dhall ", "--output ./packageSet.json` to produce this file." ]);
          return ArgParse_Basic.unformat("FILE")(Data_Either.Right.create)(ArgParse_Basic.argument([ "--input", "-i" ])(desc));
      })();
      var genLibsCmd = (function () {
          var desc = Data_Foldable.fold(Data_Foldable.foldableArray)(Data_Monoid.monoidString)([ "Generates a file that contains all packages ", "in order of how many dependencies they have (starting with 0). ", "Use this to determine the most efficient order to update the ", "ecosystem." ]);
          var cmdArgs = ArgParse_Basic.fromRecord()(ArgParse_Basic.buildArgsCons({
              reflectSymbol: function () {
                  return "finishedDepsFile";
              }
          })()()()(ArgParse_Basic.buildArgsCons({
              reflectSymbol: function () {
                  return "libraryDepFile";
              }
          })()()()(ArgParse_Basic.buildRecordArgsNil)))({
              libraryDepFile: ArgParse_Basic["default"]("./ordered-content.txt")(ArgParse_Basic.unformat("FILE")(Data_Either.Right.create)(ArgParse_Basic.argument([ "--output", "-o" ])("Indicates the file that will store the outputted content."))),
              finishedDepsFile: ArgParse_Basic["default"]("./finished-dependencies.txt")(ArgParse_Basic.unformat("FILE")(Data_Either.Right.create)(ArgParse_Basic.argument([ "--deps", "-d" ])("Indicates the file that lists packages that have already been updated on a separate line.")))
          });
          return ArgParse_Basic.command([ "lib-deps" ])(desc)(Control_Apply.applyFirst(ArgParse_Basic.applyParser)(Data_Functor.map(ArgParse_Basic.functorArgParser)(GenLibraryDeps.create)(cmdArgs))(ArgParse_Basic.flagHelp));
      })();
      var forceArg = ArgParse_Basic["boolean"](ArgParse_Basic.flag([ "--force", "-f" ])("Overwrite any files that already exist."));
      var commandArg = ArgParse_Basic.choose("command")([ genLibsCmd ]);
      return Control_Apply.apply(ArgParse_Basic.applyParser)(Control_Apply.apply(ArgParse_Basic.applyParser)(Data_Functor.map(ArgParse_Basic.functorArgParser)(function (v) {
          return function (v1) {
              return function (v2) {
                  return {
                      input: v,
                      force: v1,
                      command: v2
                  };
              };
          };
      })(inputArg))(forceArg))(commandArg);
  })();
  var parseCliArgs = ArgParse_Basic.parseArgs(Data_Foldable.foldableArray)("package-graph")("To update...")(Control_Apply.applyFirst(ArgParse_Basic.applyParser)(parser)(ArgParse_Basic.flagHelp));
  exports["GenLibraryDeps"] = GenLibraryDeps;
  exports["GenSpagoFiles"] = GenSpagoFiles;
  exports["parseCliArgs"] = parseCliArgs;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Control.Monad.Rec.Class"] = $PS["Control.Monad.Rec.Class"] || {};
  var exports = $PS["Control.Monad.Rec.Class"];      
  var Loop = (function () {
      function Loop(value0) {
          this.value0 = value0;
      };
      Loop.create = function (value0) {
          return new Loop(value0);
      };
      return Loop;
  })();
  var Done = (function () {
      function Done(value0) {
          this.value0 = value0;
      };
      Done.create = function (value0) {
          return new Done(value0);
      };
      return Done;
  })();
  var tailRec = function (f) {
      var go = function ($copy_v) {
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(v) {
              if (v instanceof Loop) {
                  $copy_v = f(v.value0);
                  return;
              };
              if (v instanceof Done) {
                  $tco_done = true;
                  return v.value0;
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 93, column 3 - line 93, column 25): " + [ v.constructor.name ]);
          };
          while (!$tco_done) {
              $tco_result = $tco_loop($copy_v);
          };
          return $tco_result;
      };
      return function ($55) {
          return go(f($55));
      };
  };
  exports["Loop"] = Loop;
  exports["Done"] = Done;
  exports["tailRec"] = tailRec;
})(PS);
(function(exports) {
  /* eslint-disable no-eq-null, eqeqeq */
  "use strict";           

  exports.stringify = function (j) {
    return JSON.stringify(j);
  };

  exports._caseJson = function (isNull, isBool, isNum, isStr, isArr, isObj, j) {
    if (j == null) return isNull();
    else if (typeof j === "boolean") return isBool(j);
    else if (typeof j === "number") return isNum(j);
    else if (typeof j === "string") return isStr(j);
    else if (Object.prototype.toString.call(j) === "[object Array]")
      return isArr(j);
    else return isObj(j);
  };
})(PS["Data.Argonaut.Core"] = PS["Data.Argonaut.Core"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Argonaut.Core"] = $PS["Data.Argonaut.Core"] || {};
  var exports = $PS["Data.Argonaut.Core"];
  var $foreign = $PS["Data.Argonaut.Core"];
  var Data_Function = $PS["Data.Function"];
  var Data_Maybe = $PS["Data.Maybe"];                        
  var verbJsonType = function (def) {
      return function (f) {
          return function (g) {
              return g(def)(f);
          };
      };
  };
  var toJsonType = verbJsonType(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
  var caseJsonString = function (d) {
      return function (f) {
          return function (j) {
              return $foreign["_caseJson"](Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, Data_Function["const"](d), Data_Function["const"](d), j);
          };
      };
  };                                        
  var caseJsonObject = function (d) {
      return function (f) {
          return function (j) {
              return $foreign["_caseJson"](Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, j);
          };
      };
  };                                        
  var toObject = toJsonType(caseJsonObject);  
  var caseJsonArray = function (d) {
      return function (f) {
          return function (j) {
              return $foreign["_caseJson"](Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), Data_Function["const"](d), f, Data_Function["const"](d), j);
          };
      };
  };                                      
  var toArray = toJsonType(caseJsonArray);
  exports["caseJsonString"] = caseJsonString;
  exports["toArray"] = toArray;
  exports["toObject"] = toObject;
  exports["stringify"] = $foreign.stringify;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };

  exports.showStringImpl = function (s) {
    var l = s.length;
    return "\"" + s.replace(
      /[\0-\x1F\x7F"\\]/g, // eslint-disable-line no-control-regex
      function (c, i) {
        switch (c) {
          case "\"":
          case "\\":
            return "\\" + c;
          case "\x07": return "\\a";
          case "\b": return "\\b";
          case "\f": return "\\f";
          case "\n": return "\\n";
          case "\r": return "\\r";
          case "\t": return "\\t";
          case "\v": return "\\v";
        }
        var k = i + 1;
        var empty = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty;
      }
    ) + "\"";
  };

  exports.showArrayImpl = function (f) {
    return function (xs) {
      var ss = [];
      for (var i = 0, l = xs.length; i < l; i++) {
        ss[i] = f(xs[i]);
      }
      return "[" + ss.join(",") + "]";
    };
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];                   
  var showString = {
      show: $foreign.showStringImpl
  };
  var showInt = {
      show: $foreign.showIntImpl
  };
  var show = function (dict) {
      return dict.show;
  };
  var showArray = function (dictShow) {
      return {
          show: $foreign.showArrayImpl(show(dictShow))
      };
  };
  exports["show"] = show;
  exports["showInt"] = showInt;
  exports["showString"] = showString;
  exports["showArray"] = showArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Argonaut.Decode.Error"] = $PS["Data.Argonaut.Decode.Error"] || {};
  var exports = $PS["Data.Argonaut.Decode.Error"];
  var Data_Argonaut_Core = $PS["Data.Argonaut.Core"];
  var Data_Show = $PS["Data.Show"];                
  var TypeMismatch = (function () {
      function TypeMismatch(value0) {
          this.value0 = value0;
      };
      TypeMismatch.create = function (value0) {
          return new TypeMismatch(value0);
      };
      return TypeMismatch;
  })();
  var UnexpectedValue = (function () {
      function UnexpectedValue(value0) {
          this.value0 = value0;
      };
      UnexpectedValue.create = function (value0) {
          return new UnexpectedValue(value0);
      };
      return UnexpectedValue;
  })();
  var AtIndex = (function () {
      function AtIndex(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      AtIndex.create = function (value0) {
          return function (value1) {
              return new AtIndex(value0, value1);
          };
      };
      return AtIndex;
  })();
  var AtKey = (function () {
      function AtKey(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      AtKey.create = function (value0) {
          return function (value1) {
              return new AtKey(value0, value1);
          };
      };
      return AtKey;
  })();
  var Named = (function () {
      function Named(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Named.create = function (value0) {
          return function (value1) {
              return new Named(value0, value1);
          };
      };
      return Named;
  })();
  var MissingValue = (function () {
      function MissingValue() {

      };
      MissingValue.value = new MissingValue();
      return MissingValue;
  })();
  var printJsonDecodeError = function (err) {
      var go = function (v) {
          if (v instanceof TypeMismatch) {
              return "  Expected value of type '" + (v.value0 + "'.");
          };
          if (v instanceof UnexpectedValue) {
              return "  Unexpected value " + (Data_Argonaut_Core.stringify(v.value0) + ".");
          };
          if (v instanceof AtIndex) {
              return "  At array index " + (Data_Show.show(Data_Show.showInt)(v.value0) + (":\x0a" + go(v.value1)));
          };
          if (v instanceof AtKey) {
              return "  At object key '" + (v.value0 + ("':\x0a" + go(v.value1)));
          };
          if (v instanceof Named) {
              return "  Under '" + (v.value0 + ("':\x0a" + go(v.value1)));
          };
          if (v instanceof MissingValue) {
              return "  No value was found.";
          };
          throw new Error("Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): " + [ v.constructor.name ]);
      };
      return "An error occurred while decoding a JSON value:\x0a" + go(err);
  };
  exports["TypeMismatch"] = TypeMismatch;
  exports["AtIndex"] = AtIndex;
  exports["AtKey"] = AtKey;
  exports["Named"] = Named;
  exports["MissingValue"] = MissingValue;
  exports["printJsonDecodeError"] = printJsonDecodeError;
})(PS);
(function(exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = (function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                case 0: return pure([]);
                case 1: return map(array1)(f(array[bot]));
                case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  // This slightly tricky pivot selection aims to produce two
                  // even-length partitions where possible.
                  var pivot = bot + Math.floor((top - bot) / 4) * 2;
                  return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  })();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];            
  var traverse = function (dict) {
      return dict.traverse;
  };
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var traversableArray = {
      traverse: function (dictApplicative) {
          return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
      },
      sequence: function (dictApplicative) {
          return sequenceDefault(traversableArray)(dictApplicative);
      },
      Functor0: function () {
          return Data_Functor.functorArray;
      },
      Foldable1: function () {
          return Data_Foldable.foldableArray;
      }
  };
  var sequence = function (dict) {
      return dict.sequence;
  };
  exports["traverse"] = traverse;
  exports["sequence"] = sequence;
  exports["traversableArray"] = traversableArray;
})(PS);
(function(exports) {
  "use strict";

  exports.mapWithIndexArray = function (f) {
    return function (xs) {
      var l = xs.length;
      var result = Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(i)(xs[i]);
      }
      return result;
    };
  };
})(PS["Data.FunctorWithIndex"] = PS["Data.FunctorWithIndex"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.FunctorWithIndex"] = $PS["Data.FunctorWithIndex"] || {};
  var exports = $PS["Data.FunctorWithIndex"];
  var $foreign = $PS["Data.FunctorWithIndex"];
  var Data_Functor = $PS["Data.Functor"];          
  var mapWithIndex = function (dict) {
      return dict.mapWithIndex;
  };
  var functorWithIndexArray = {
      mapWithIndex: $foreign.mapWithIndexArray,
      Functor0: function () {
          return Data_Functor.functorArray;
      }
  };
  exports["mapWithIndex"] = mapWithIndex;
  exports["functorWithIndexArray"] = functorWithIndexArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.FoldableWithIndex"] = $PS["Data.FoldableWithIndex"] || {};
  var exports = $PS["Data.FoldableWithIndex"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_FunctorWithIndex = $PS["Data.FunctorWithIndex"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Tuple = $PS["Data.Tuple"];              
  var foldrWithIndex = function (dict) {
      return dict.foldrWithIndex;
  };
  var foldlWithIndex = function (dict) {
      return dict.foldlWithIndex;
  };
  var foldMapWithIndexDefaultR = function (dictFoldableWithIndex) {
      return function (dictMonoid) {
          return function (f) {
              return foldrWithIndex(dictFoldableWithIndex)(function (i) {
                  return function (x) {
                      return function (acc) {
                          return Data_Semigroup.append(dictMonoid.Semigroup0())(f(i)(x))(acc);
                      };
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableWithIndexArray = {
      foldrWithIndex: function (f) {
          return function (z) {
              var $167 = Data_Foldable.foldr(Data_Foldable.foldableArray)(function (v) {
                  return function (y) {
                      return f(v.value0)(v.value1)(y);
                  };
              })(z);
              var $168 = Data_FunctorWithIndex.mapWithIndex(Data_FunctorWithIndex.functorWithIndexArray)(Data_Tuple.Tuple.create);
              return function ($169) {
                  return $167($168($169));
              };
          };
      },
      foldlWithIndex: function (f) {
          return function (z) {
              var $170 = Data_Foldable.foldl(Data_Foldable.foldableArray)(function (y) {
                  return function (v) {
                      return f(v.value0)(y)(v.value1);
                  };
              })(z);
              var $171 = Data_FunctorWithIndex.mapWithIndex(Data_FunctorWithIndex.functorWithIndexArray)(Data_Tuple.Tuple.create);
              return function ($172) {
                  return $170($171($172));
              };
          };
      },
      foldMapWithIndex: function (dictMonoid) {
          return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
      },
      Foldable0: function () {
          return Data_Foldable.foldableArray;
      }
  };
  exports["foldlWithIndex"] = foldlWithIndex;
  exports["foldableWithIndexArray"] = foldableWithIndexArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.TraversableWithIndex"] = $PS["Data.TraversableWithIndex"] || {};
  var exports = $PS["Data.TraversableWithIndex"];
  var Data_FoldableWithIndex = $PS["Data.FoldableWithIndex"];
  var Data_Function = $PS["Data.Function"];
  var Data_FunctorWithIndex = $PS["Data.FunctorWithIndex"];
  var Data_Traversable = $PS["Data.Traversable"];  
  var traverseWithIndexDefault = function (dictTraversableWithIndex) {
      return function (dictApplicative) {
          return function (f) {
              var $64 = Data_Traversable.sequence(dictTraversableWithIndex.Traversable2())(dictApplicative);
              var $65 = Data_FunctorWithIndex.mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0())(f);
              return function ($66) {
                  return $64($65($66));
              };
          };
      };
  };
  var traverseWithIndex = function (dict) {
      return dict.traverseWithIndex;
  };
  var traversableWithIndexArray = {
      traverseWithIndex: function (dictApplicative) {
          return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
      },
      FunctorWithIndex0: function () {
          return Data_FunctorWithIndex.functorWithIndexArray;
      },
      FoldableWithIndex1: function () {
          return Data_FoldableWithIndex.foldableWithIndexArray;
      },
      Traversable2: function () {
          return Data_Traversable.traversableArray;
      }
  };
  var forWithIndex = function (dictApplicative) {
      return function (dictTraversableWithIndex) {
          return Data_Function.flip(traverseWithIndex(dictTraversableWithIndex)(dictApplicative));
      };
  };
  exports["traverseWithIndex"] = traverseWithIndex;
  exports["forWithIndex"] = forWithIndex;
  exports["traversableWithIndexArray"] = traversableWithIndexArray;
})(PS);
(function(exports) {
  "use strict";

  exports._copyST = function (m) {
    return function () {
      var r = {};
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  };

  exports.empty = {};

  exports.runST = function (f) {
    return f();
  };

  exports._fmapObject = function (m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  };

  exports._mapWithKey = function (m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(k)(m0[k]);
      }
    }
    return m;
  };

  exports._foldM = function (bind) {
    return function (f) {
      return function (mz) {
        return function (m) {
          var acc = mz;
          function g(k) {
            return function (z) {
              return f(z)(k)(m[k]);
            };
          }
          for (var k in m) {
            if (hasOwnProperty.call(m, k)) {
              acc = bind(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  };

  exports._lookup = function (no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  };

  function toArrayWithKey(f) {
    return function (m) {
      var r = [];
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }

  exports.toArrayWithKey = toArrayWithKey;
})(PS["Foreign.Object"] = PS["Foreign.Object"] || {});
(function(exports) {
  "use strict";

  exports.runFn4 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return fn(a, b, c, d);
          };
        };
      };
    };
  };
})(PS["Data.Function.Uncurried"] = PS["Data.Function.Uncurried"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Function.Uncurried"] = $PS["Data.Function.Uncurried"] || {};
  var exports = $PS["Data.Function.Uncurried"];
  var $foreign = $PS["Data.Function.Uncurried"];
  exports["runFn4"] = $foreign.runFn4;
})(PS);
(function(exports) {
  "use strict";

  exports.poke = function (k) {
    return function (v) {
      return function (m) {
        return function () {
          m[k] = v;
          return m;
        };
      };
    };
  };
})(PS["Foreign.Object.ST"] = PS["Foreign.Object.ST"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Foreign.Object.ST"] = $PS["Foreign.Object.ST"] || {};
  var exports = $PS["Foreign.Object.ST"];
  var $foreign = $PS["Foreign.Object.ST"];
  exports["poke"] = $foreign.poke;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Foreign.Object"] = $PS["Foreign.Object"] || {};
  var exports = $PS["Foreign.Object"];
  var $foreign = $PS["Foreign.Object"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Function_Uncurried = $PS["Data.Function.Uncurried"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_TraversableWithIndex = $PS["Data.TraversableWithIndex"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Foreign_Object_ST = $PS["Foreign.Object.ST"];        
  var values = $foreign.toArrayWithKey(function (v) {
      return function (v1) {
          return v1;
      };
  });                                                            
  var thawST = $foreign["_copyST"];
  var mutate = function (f) {
      return function (m) {
          return $foreign.runST(function __do() {
              var s = thawST(m)();
              f(s)();
              return s;
          });
      };
  };                                                                                                    
  var mapWithKey = function (f) {
      return function (m) {
          return $foreign["_mapWithKey"](m, f);
      };
  };
  var lookup = Data_Function_Uncurried.runFn4($foreign["_lookup"])(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
  var insert = function (k) {
      return function (v) {
          return mutate(Foreign_Object_ST.poke(k)(v));
      };
  };
  var functorObject = {
      map: function (f) {
          return function (m) {
              return $foreign["_fmapObject"](m, f);
          };
      }
  };
  var functorWithIndexObject = {
      mapWithIndex: mapWithKey,
      Functor0: function () {
          return functorObject;
      }
  };
  var fold = $foreign["_foldM"](Data_Function.applyFlipped);
  var foldMap = function (dictMonoid) {
      return function (f) {
          return fold(function (acc) {
              return function (k) {
                  return function (v) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f(k)(v));
                  };
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  };
  var foldableObject = {
      foldl: function (f) {
          return fold(function (z) {
              return function (v) {
                  return f(z);
              };
          });
      },
      foldr: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldr(Data_Foldable.foldableArray)(f)(z)(values(m));
              };
          };
      },
      foldMap: function (dictMonoid) {
          return function (f) {
              return foldMap(dictMonoid)(Data_Function["const"](f));
          };
      }
  };
  var foldableWithIndexObject = {
      foldlWithIndex: function (f) {
          return fold(Data_Function.flip(f));
      },
      foldrWithIndex: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldr(Data_Foldable.foldableArray)(Data_Tuple.uncurry(f))(z)($foreign.toArrayWithKey(Data_Tuple.Tuple.create)(m));
              };
          };
      },
      foldMapWithIndex: function (dictMonoid) {
          return foldMap(dictMonoid);
      },
      Foldable0: function () {
          return foldableObject;
      }
  };
  var traversableWithIndexObject = {
      traverseWithIndex: function (dictApplicative) {
          return function (f) {
              return function (ms) {
                  return fold(function (acc) {
                      return function (k) {
                          return function (v) {
                              return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Function.flip(insert(k)))(acc))(f(k)(v));
                          };
                      };
                  })(Control_Applicative.pure(dictApplicative)($foreign.empty))(ms);
              };
          };
      },
      FunctorWithIndex0: function () {
          return functorWithIndexObject;
      },
      FoldableWithIndex1: function () {
          return foldableWithIndexObject;
      },
      Traversable2: function () {
          return traversableObject;
      }
  };
  var traversableObject = {
      traverse: function (dictApplicative) {
          var $42 = Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexObject)(dictApplicative);
          return function ($43) {
              return $42(Data_Function["const"]($43));
          };
      },
      sequence: function (dictApplicative) {
          return Data_Traversable.traverse(traversableObject)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      },
      Functor0: function () {
          return functorObject;
      },
      Foldable1: function () {
          return foldableObject;
      }
  };
  exports["lookup"] = lookup;
  exports["foldableObject"] = foldableObject;
  exports["traversableObject"] = traversableObject;
  exports["traversableWithIndexObject"] = traversableWithIndexObject;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Argonaut.Decode.Decoders"] = $PS["Data.Argonaut.Decode.Decoders"] || {};
  var exports = $PS["Data.Argonaut.Decode.Decoders"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Argonaut_Core = $PS["Data.Argonaut.Core"];
  var Data_Argonaut_Decode_Error = $PS["Data.Argonaut.Decode.Error"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_TraversableWithIndex = $PS["Data.TraversableWithIndex"];
  var Foreign_Object = $PS["Foreign.Object"];
  var decodeString = Data_Argonaut_Core.caseJsonString(new Data_Either.Left(new Data_Argonaut_Decode_Error.TypeMismatch("String")))(Data_Either.Right.create);
  var decodeJObject = (function () {
      var $20 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Object"));
      return function ($21) {
          return $20(Data_Argonaut_Core.toObject($21));
      };
  })();
  var decodeJArray = (function () {
      var $22 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Array"));
      return function ($23) {
          return $22(Data_Argonaut_Core.toArray($23));
      };
  })();
  var decodeForeignObject = function (decoder) {
      return Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
          var $56 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Data_Argonaut_Decode_Error.Named.create("ForeignObject"));
          var $57 = Data_Traversable.traverse(Foreign_Object.traversableObject)(Data_Either.applicativeEither)(decoder);
          return function ($58) {
              return $56($57($58));
          };
      })())(decodeJObject);
  };                                                                                                                                                             
  var decodeArray = function (decoder) {
      return Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
          var $59 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Data_Argonaut_Decode_Error.Named.create("Array"));
          var $60 = Data_TraversableWithIndex.traverseWithIndex(Data_TraversableWithIndex.traversableWithIndexArray)(Data_Either.applicativeEither)(function (i) {
              var $62 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Data_Argonaut_Decode_Error.AtIndex.create(i));
              return function ($63) {
                  return $62(decoder($63));
              };
          });
          return function ($61) {
              return $59($60($61));
          };
      })())(decodeJArray);
  };
  exports["decodeString"] = decodeString;
  exports["decodeForeignObject"] = decodeForeignObject;
  exports["decodeArray"] = decodeArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Argonaut.Decode.Class"] = $PS["Data.Argonaut.Decode.Class"] || {};
  var exports = $PS["Data.Argonaut.Decode.Class"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Argonaut_Core = $PS["Data.Argonaut.Core"];
  var Data_Argonaut_Decode_Decoders = $PS["Data.Argonaut.Decode.Decoders"];
  var Data_Argonaut_Decode_Error = $PS["Data.Argonaut.Decode.Error"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Foreign_Object = $PS["Foreign.Object"];
  var Record = $PS["Record"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var gDecodeJsonNil = {
      gDecodeJson: function (v) {
          return function (v1) {
              return new Data_Either.Right({});
          };
      }
  };
  var gDecodeJson = function (dict) {
      return dict.gDecodeJson;
  };
  var decodeRecord = function (dictGDecodeJson) {
      return function () {
          return {
              decodeJson: function (json) {
                  var v = Data_Argonaut_Core.toObject(json);
                  if (v instanceof Data_Maybe.Just) {
                      return gDecodeJson(dictGDecodeJson)(v.value0)(Type_Proxy["Proxy"].value);
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      return new Data_Either.Left(new Data_Argonaut_Decode_Error.TypeMismatch("Object"));
                  };
                  throw new Error("Failed pattern match at Data.Argonaut.Decode.Class (line 103, column 5 - line 105, column 46): " + [ v.constructor.name ]);
              }
          };
      };
  };
  var decodeJsonString = {
      decodeJson: Data_Argonaut_Decode_Decoders.decodeString
  };
  var decodeJsonJson = {
      decodeJson: Data_Either.Right.create
  };
  var decodeJsonField = function (dict) {
      return dict.decodeJsonField;
  };
  var gDecodeJsonCons = function (dictDecodeJsonField) {
      return function (dictGDecodeJson) {
          return function (dictIsSymbol) {
              return function () {
                  return function () {
                      return {
                          gDecodeJson: function (object) {
                              return function (v) {
                                  var fieldName = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value);
                                  var fieldValue = Foreign_Object.lookup(fieldName)(object);
                                  var v1 = decodeJsonField(dictDecodeJsonField)(fieldValue);
                                  if (v1 instanceof Data_Maybe.Just) {
                                      return Control_Bind.bind(Data_Either.bindEither)(Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Data_Argonaut_Decode_Error.AtKey.create(fieldName))(v1.value0))(function (val) {
                                          return Control_Bind.bind(Data_Either.bindEither)(gDecodeJson(dictGDecodeJson)(object)(Type_Proxy["Proxy"].value))(function (rest) {
                                              return new Data_Either.Right(Record.insert(dictIsSymbol)()()(Type_Proxy["Proxy"].value)(val)(rest));
                                          });
                                      });
                                  };
                                  if (v1 instanceof Data_Maybe.Nothing) {
                                      return new Data_Either.Left(new Data_Argonaut_Decode_Error.AtKey(fieldName, Data_Argonaut_Decode_Error.MissingValue.value));
                                  };
                                  throw new Error("Failed pattern match at Data.Argonaut.Decode.Class (line 127, column 5 - line 134, column 44): " + [ v1.constructor.name ]);
                              };
                          }
                      };
                  };
              };
          };
      };
  };
  var decodeJson = function (dict) {
      return dict.decodeJson;
  };
  var decodeForeignObject = function (dictDecodeJson) {
      return {
          decodeJson: Data_Argonaut_Decode_Decoders.decodeForeignObject(decodeJson(dictDecodeJson))
      };
  };
  var decodeFieldId = function (dictDecodeJson) {
      return {
          decodeJsonField: function (j) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(decodeJson(dictDecodeJson))(j);
          }
      };
  };
  var decodeArray = function (dictDecodeJson) {
      return {
          decodeJson: Data_Argonaut_Decode_Decoders.decodeArray(decodeJson(dictDecodeJson))
      };
  };
  exports["decodeJson"] = decodeJson;
  exports["decodeJsonString"] = decodeJsonString;
  exports["decodeJsonJson"] = decodeJsonJson;
  exports["decodeForeignObject"] = decodeForeignObject;
  exports["decodeArray"] = decodeArray;
  exports["decodeRecord"] = decodeRecord;
  exports["gDecodeJsonNil"] = gDecodeJsonNil;
  exports["gDecodeJsonCons"] = gDecodeJsonCons;
  exports["decodeFieldId"] = decodeFieldId;
})(PS);
(function(exports) {
  "use strict";

  exports._jsonParser = function (fail, succ, s) {
    try {
      return succ(JSON.parse(s));
    }
    catch (e) {
      return fail(e.message);
    }
  };
})(PS["Data.Argonaut.Parser"] = PS["Data.Argonaut.Parser"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Argonaut.Parser"] = $PS["Data.Argonaut.Parser"] || {};
  var exports = $PS["Data.Argonaut.Parser"];
  var $foreign = $PS["Data.Argonaut.Parser"];
  var Data_Either = $PS["Data.Either"];                
  var jsonParser = function (j) {
      return $foreign["_jsonParser"](Data_Either.Left.create, Data_Either.Right.create, j);
  };
  exports["jsonParser"] = jsonParser;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Map.Internal"] = $PS["Data.Map.Internal"] || {};
  var exports = $PS["Data.Map.Internal"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_List_Types = $PS["Data.List.Types"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];                
  var Leaf = (function () {
      function Leaf() {

      };
      Leaf.value = new Leaf();
      return Leaf;
  })();
  var Two = (function () {
      function Two(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      Two.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new Two(value0, value1, value2, value3);
                  };
              };
          };
      };
      return Two;
  })();
  var Three = (function () {
      function Three(value0, value1, value2, value3, value4, value5, value6) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
          this.value6 = value6;
      };
      Three.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return function (value6) {
                                  return new Three(value0, value1, value2, value3, value4, value5, value6);
                              };
                          };
                      };
                  };
              };
          };
      };
      return Three;
  })();
  var TwoLeft = (function () {
      function TwoLeft(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoLeft(value0, value1, value2);
              };
          };
      };
      return TwoLeft;
  })();
  var TwoRight = (function () {
      function TwoRight(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoRight(value0, value1, value2);
              };
          };
      };
      return TwoRight;
  })();
  var ThreeLeft = (function () {
      function ThreeLeft(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeLeft(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeLeft;
  })();
  var ThreeMiddle = (function () {
      function ThreeMiddle(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeMiddle.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeMiddle(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeMiddle;
  })();
  var ThreeRight = (function () {
      function ThreeRight(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeRight(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeRight;
  })();
  var KickUp = (function () {
      function KickUp(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      KickUp.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new KickUp(value0, value1, value2, value3);
                  };
              };
          };
      };
      return KickUp;
  })();
  var values = function (v) {
      if (v instanceof Leaf) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Two) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(values(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value5))(values(v.value6)))));
      };
      throw new Error("Failed pattern match at Data.Map.Internal (line 626, column 1 - line 626, column 40): " + [ v.constructor.name ]);
  };
  var singleton = function (k) {
      return function (v) {
          return new Two(Leaf.value, k, v, Leaf.value);
      };
  };
  var toUnfoldable = function (dictUnfoldable) {
      return function (m) {
          var go = function ($copy_v) {
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof Leaf) {
                          $copy_v = v.value1;
                          return;
                      };
                      if (v.value0 instanceof Two && (v.value0.value0 instanceof Leaf && v.value0.value3 instanceof Leaf)) {
                          $tco_done = true;
                          return new Data_Maybe.Just(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), v.value1));
                      };
                      if (v.value0 instanceof Two && v.value0.value0 instanceof Leaf) {
                          $tco_done = true;
                          return new Data_Maybe.Just(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));
                      };
                      if (v.value0 instanceof Two) {
                          $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));
                          return;
                      };
                      if (v.value0 instanceof Three) {
                          $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, new Data_List_Types.Cons(singleton(v.value0.value4)(v.value0.value5), new Data_List_Types.Cons(v.value0.value6, v.value1)))));
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 591, column 18 - line 600, column 71): " + [ v.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 590, column 3 - line 590, column 19): " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($copy_v);
              };
              return $tco_result;
          };
          return Data_Unfoldable.unfoldr(dictUnfoldable)(go)(new Data_List_Types.Cons(m, Data_List_Types.Nil.value));
      };
  };
  var lookup = function (dictOrd) {
      return function (k) {
          var comp = Data_Ord.compare(dictOrd);
          var go = function ($copy_v) {
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v) {
                  if (v instanceof Leaf) {
                      $tco_done = true;
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Two) {
                      var v2 = comp(k)(v.value1);
                      if (v2 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      if (v2 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  if (v instanceof Three) {
                      var v3 = comp(k)(v.value1);
                      if (v3 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value2);
                      };
                      var v4 = comp(k)(v.value4);
                      if (v4 instanceof Data_Ordering.EQ) {
                          $tco_done = true;
                          return new Data_Maybe.Just(v.value5);
                      };
                      if (v3 instanceof Data_Ordering.LT) {
                          $copy_v = v.value0;
                          return;
                      };
                      if (v4 instanceof Data_Ordering.GT) {
                          $copy_v = v.value6;
                          return;
                      };
                      $copy_v = v.value3;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 211, column 5 - line 211, column 22): " + [ v.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($copy_v);
              };
              return $tco_result;
          };
          return go;
      };
  };
  var keys = function (v) {
      if (v instanceof Leaf) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Two) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(keys(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value4))(keys(v.value6)))));
      };
      throw new Error("Failed pattern match at Data.Map.Internal (line 620, column 1 - line 620, column 38): " + [ v.constructor.name ]);
  };
  var functorMap = {
      map: function (v) {
          return function (v1) {
              if (v1 instanceof Leaf) {
                  return Leaf.value;
              };
              if (v1 instanceof Two) {
                  return new Two(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3));
              };
              if (v1 instanceof Three) {
                  return new Three(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3), v1.value4, v(v1.value5), Data_Functor.map(functorMap)(v)(v1.value6));
              };
              throw new Error("Failed pattern match at Data.Map.Internal (line 101, column 1 - line 104, column 110): " + [ v.constructor.name, v1.constructor.name ]);
          };
      }
  };
  var fromZipper = function ($copy_dictOrd) {
      return function ($copy_v) {
          return function ($copy_tree) {
              var $tco_var_dictOrd = $copy_dictOrd;
              var $tco_var_v = $copy_v;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(dictOrd, v, tree) {
                  if (v instanceof Data_List_Types.Nil) {
                      $tco_done = true;
                      return tree;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof TwoLeft) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Two(tree, v.value0.value0, v.value0.value1, v.value0.value2);
                          return;
                      };
                      if (v.value0 instanceof TwoRight) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Two(v.value0.value0, v.value0.value1, v.value0.value2, tree);
                          return;
                      };
                      if (v.value0 instanceof ThreeLeft) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);
                          return;
                      };
                      if (v.value0 instanceof ThreeMiddle) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, tree, v.value0.value3, v.value0.value4, v.value0.value5);
                          return;
                      };
                      if (v.value0 instanceof ThreeRight) {
                          $tco_var_dictOrd = dictOrd;
                          $tco_var_v = v.value1;
                          $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, tree);
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 432, column 3 - line 437, column 88): " + [ v.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 429, column 1 - line 429, column 80): " + [ v.constructor.name, tree.constructor.name ]);
              };
              while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_dictOrd, $tco_var_v, $copy_tree);
              };
              return $tco_result;
          };
      };
  };
  var insert = function (dictOrd) {
      return function (k) {
          return function (v) {
              var up = function ($copy_v1) {
                  return function ($copy_v2) {
                      var $tco_var_v1 = $copy_v1;
                      var $tco_done = false;
                      var $tco_result;
                      function $tco_loop(v1, v2) {
                          if (v1 instanceof Data_List_Types.Nil) {
                              $tco_done = true;
                              return new Two(v2.value0, v2.value1, v2.value2, v2.value3);
                          };
                          if (v1 instanceof Data_List_Types.Cons) {
                              if (v1.value0 instanceof TwoLeft) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(v1.value1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, v1.value0.value0, v1.value0.value1, v1.value0.value2));
                              };
                              if (v1.value0 instanceof TwoRight) {
                                  $tco_done = true;
                                  return fromZipper(dictOrd)(v1.value1)(new Three(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0, v2.value1, v2.value2, v2.value3));
                              };
                              if (v1.value0 instanceof ThreeLeft) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v2.value0, v2.value1, v2.value2, v2.value3), v1.value0.value0, v1.value0.value1, new Two(v1.value0.value2, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                                  return;
                              };
                              if (v1.value0 instanceof ThreeMiddle) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0), v2.value1, v2.value2, new Two(v2.value3, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                                  return;
                              };
                              if (v1.value0 instanceof ThreeRight) {
                                  $tco_var_v1 = v1.value1;
                                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v1.value0.value3), v1.value0.value4, v1.value0.value5, new Two(v2.value0, v2.value1, v2.value2, v2.value3));
                                  return;
                              };
                              throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 5 - line 473, column 108): " + [ v1.value0.constructor.name, v2.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Map.Internal (line 465, column 3 - line 465, column 56): " + [ v1.constructor.name, v2.constructor.name ]);
                      };
                      while (!$tco_done) {
                          $tco_result = $tco_loop($tco_var_v1, $copy_v2);
                      };
                      return $tco_result;
                  };
              };
              var comp = Data_Ord.compare(dictOrd);
              var down = function ($copy_ctx) {
                  return function ($copy_v1) {
                      var $tco_var_ctx = $copy_ctx;
                      var $tco_done1 = false;
                      var $tco_result;
                      function $tco_loop(ctx, v1) {
                          if (v1 instanceof Leaf) {
                              $tco_done1 = true;
                              return up(ctx)(new KickUp(Leaf.value, k, v, Leaf.value));
                          };
                          if (v1 instanceof Two) {
                              var v2 = comp(k)(v1.value1);
                              if (v2 instanceof Data_Ordering.EQ) {
                                  $tco_done1 = true;
                                  return fromZipper(dictOrd)(ctx)(new Two(v1.value0, k, v, v1.value3));
                              };
                              if (v2 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(v1.value1, v1.value2, v1.value3), ctx);
                                  $copy_v1 = v1.value0;
                                  return;
                              };
                              $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(v1.value0, v1.value1, v1.value2), ctx);
                              $copy_v1 = v1.value3;
                              return;
                          };
                          if (v1 instanceof Three) {
                              var v3 = comp(k)(v1.value1);
                              if (v3 instanceof Data_Ordering.EQ) {
                                  $tco_done1 = true;
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, k, v, v1.value3, v1.value4, v1.value5, v1.value6));
                              };
                              var v4 = comp(k)(v1.value4);
                              if (v4 instanceof Data_Ordering.EQ) {
                                  $tco_done1 = true;
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, k, v, v1.value6));
                              };
                              if (v3 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(v1.value1, v1.value2, v1.value3, v1.value4, v1.value5, v1.value6), ctx);
                                  $copy_v1 = v1.value0;
                                  return;
                              };
                              if (v3 instanceof Data_Ordering.GT && v4 instanceof Data_Ordering.LT) {
                                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(v1.value0, v1.value1, v1.value2, v1.value4, v1.value5, v1.value6), ctx);
                                  $copy_v1 = v1.value3;
                                  return;
                              };
                              $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(v1.value0, v1.value1, v1.value2, v1.value3, v1.value4, v1.value5), ctx);
                              $copy_v1 = v1.value6;
                              return;
                          };
                          throw new Error("Failed pattern match at Data.Map.Internal (line 448, column 3 - line 448, column 55): " + [ ctx.constructor.name, v1.constructor.name ]);
                      };
                      while (!$tco_done1) {
                          $tco_result = $tco_loop($tco_var_ctx, $copy_v1);
                      };
                      return $tco_result;
                  };
              };
              return down(Data_List_Types.Nil.value);
          };
      };
  };
  var pop = function (dictOrd) {
      return function (k) {
          var up = function ($copy_ctxs) {
              return function ($copy_tree) {
                  var $tco_var_ctxs = $copy_ctxs;
                  var $tco_done = false;
                  var $tco_result;
                  function $tco_loop(ctxs, tree) {
                      if (ctxs instanceof Data_List_Types.Nil) {
                          $tco_done = true;
                          return tree;
                      };
                      if (ctxs instanceof Data_List_Types.Cons) {
                          if (ctxs.value0 instanceof TwoLeft && (ctxs.value0.value2 instanceof Leaf && tree instanceof Leaf)) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value));
                          };
                          if (ctxs.value0 instanceof TwoRight && (ctxs.value0.value0 instanceof Leaf && tree instanceof Leaf)) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value));
                          };
                          if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Two) {
                              $tco_var_ctxs = ctxs.value1;
                              $copy_tree = new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3);
                              return;
                          };
                          if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Two) {
                              $tco_var_ctxs = ctxs.value1;
                              $copy_tree = new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree);
                              return;
                          };
                          if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6)));
                          };
                          if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree)));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && (ctxs.value0.value2 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeRight && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value3 instanceof Leaf && tree instanceof Leaf))) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value4, ctxs.value0.value5, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Two) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Two) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Two) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0, ctxs.value0.value5.value1, ctxs.value0.value5.value2, ctxs.value0.value5.value3)));
                          };
                          if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Two) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3, ctxs.value0.value4, ctxs.value0.value5, tree)));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0), ctxs.value0.value5.value1, ctxs.value0.value5.value2, new Two(ctxs.value0.value5.value3, ctxs.value0.value5.value4, ctxs.value0.value5.value5, ctxs.value0.value5.value6)));
                          };
                          if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Three) {
                              $tco_done = true;
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3), ctxs.value0.value3.value4, ctxs.value0.value3.value5, new Two(ctxs.value0.value3.value6, ctxs.value0.value4, ctxs.value0.value5, tree)));
                          };
                          throw new Error("Failed pattern match at Data.Map.Internal (line 525, column 9 - line 542, column 136): " + [ ctxs.value0.constructor.name, tree.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 522, column 5 - line 542, column 136): " + [ ctxs.constructor.name ]);
                  };
                  while (!$tco_done) {
                      $tco_result = $tco_loop($tco_var_ctxs, $copy_tree);
                  };
                  return $tco_result;
              };
          };
          var removeMaxNode = function ($copy_ctx) {
              return function ($copy_m) {
                  var $tco_var_ctx = $copy_ctx;
                  var $tco_done1 = false;
                  var $tco_result;
                  function $tco_loop(ctx, m) {
                      if (m instanceof Two && (m.value0 instanceof Leaf && m.value3 instanceof Leaf)) {
                          $tco_done1 = true;
                          return up(ctx)(Leaf.value);
                      };
                      if (m instanceof Two) {
                          $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);
                          $copy_m = m.value3;
                          return;
                      };
                      if (m instanceof Three && (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf))) {
                          $tco_done1 = true;
                          return up(new Data_List_Types.Cons(new TwoRight(Leaf.value, m.value1, m.value2), ctx))(Leaf.value);
                      };
                      if (m instanceof Three) {
                          $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);
                          $copy_m = m.value6;
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 554, column 5 - line 558, column 107): " + [ m.constructor.name ]);
                  };
                  while (!$tco_done1) {
                      $tco_result = $tco_loop($tco_var_ctx, $copy_m);
                  };
                  return $tco_result;
              };
          };
          var maxNode = function ($copy_m) {
              var $tco_done2 = false;
              var $tco_result;
              function $tco_loop(m) {
                  if (m instanceof Two && m.value3 instanceof Leaf) {
                      $tco_done2 = true;
                      return {
                          key: m.value1,
                          value: m.value2
                      };
                  };
                  if (m instanceof Two) {
                      $copy_m = m.value3;
                      return;
                  };
                  if (m instanceof Three && m.value6 instanceof Leaf) {
                      $tco_done2 = true;
                      return {
                          key: m.value4,
                          value: m.value5
                      };
                  };
                  if (m instanceof Three) {
                      $copy_m = m.value6;
                      return;
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 545, column 33 - line 549, column 45): " + [ m.constructor.name ]);
              };
              while (!$tco_done2) {
                  $tco_result = $tco_loop($copy_m);
              };
              return $tco_result;
          };
          var comp = Data_Ord.compare(dictOrd);
          var down = function ($copy_ctx) {
              return function ($copy_m) {
                  var $tco_var_ctx = $copy_ctx;
                  var $tco_done3 = false;
                  var $tco_result;
                  function $tco_loop(ctx, m) {
                      if (m instanceof Leaf) {
                          $tco_done3 = true;
                          return Data_Maybe.Nothing.value;
                      };
                      if (m instanceof Two) {
                          var v = comp(k)(m.value1);
                          if (m.value3 instanceof Leaf && v instanceof Data_Ordering.EQ) {
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, up(ctx)(Leaf.value)));
                          };
                          if (v instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value0);
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new TwoLeft(max.key, max.value, m.value3), ctx))(m.value0)));
                          };
                          if (v instanceof Data_Ordering.LT) {
                              $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(m.value1, m.value2, m.value3), ctx);
                              $copy_m = m.value0;
                              return;
                          };
                          $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);
                          $copy_m = m.value3;
                          return;
                      };
                      if (m instanceof Three) {
                          var leaves = (function () {
                              if (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf)) {
                                  return true;
                              };
                              return false;
                          })();
                          var v = comp(k)(m.value4);
                          var v3 = comp(k)(m.value1);
                          if (leaves && v3 instanceof Data_Ordering.EQ) {
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value4, m.value5, Leaf.value))));
                          };
                          if (leaves && v instanceof Data_Ordering.EQ) {
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value1, m.value2, Leaf.value))));
                          };
                          if (v3 instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value0);
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new ThreeLeft(max.key, max.value, m.value3, m.value4, m.value5, m.value6), ctx))(m.value0)));
                          };
                          if (v instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value3);
                              $tco_done3 = true;
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, removeMaxNode(new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, max.key, max.value, m.value6), ctx))(m.value3)));
                          };
                          if (v3 instanceof Data_Ordering.LT) {
                              $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(m.value1, m.value2, m.value3, m.value4, m.value5, m.value6), ctx);
                              $copy_m = m.value0;
                              return;
                          };
                          if (v3 instanceof Data_Ordering.GT && v instanceof Data_Ordering.LT) {
                              $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, m.value4, m.value5, m.value6), ctx);
                              $copy_m = m.value3;
                              return;
                          };
                          $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);
                          $copy_m = m.value6;
                          return;
                      };
                      throw new Error("Failed pattern match at Data.Map.Internal (line 495, column 34 - line 518, column 80): " + [ m.constructor.name ]);
                  };
                  while (!$tco_done3) {
                      $tco_result = $tco_loop($tco_var_ctx, $copy_m);
                  };
                  return $tco_result;
              };
          };
          return down(Data_List_Types.Nil.value);
      };
  };
  var foldableMap = {
      foldl: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldl(Data_List_Types.foldableList)(f)(z)(values(m));
              };
          };
      },
      foldr: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(z)(values(m));
              };
          };
      },
      foldMap: function (dictMonoid) {
          return function (f) {
              return function (m) {
                  return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f)(values(m));
              };
          };
      }
  };
  var empty = Leaf.value;
  var fromFoldable = function (dictOrd) {
      return function (dictFoldable) {
          return Data_Foldable.foldl(dictFoldable)(function (m) {
              return function (v) {
                  return insert(dictOrd)(v.value0)(v.value1)(m);
              };
          })(empty);
      };
  };
  var $$delete = function (dictOrd) {
      return function (k) {
          return function (m) {
              return Data_Maybe.maybe(m)(Data_Tuple.snd)(pop(dictOrd)(k)(m));
          };
      };
  };
  var asList = Control_Category.identity(Control_Category.categoryFn);
  var foldableWithIndexMap = {
      foldlWithIndex: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldl(Data_List_Types.foldableList)((function () {
                      var $756 = Data_Function.flip(f);
                      return function ($757) {
                          return Data_Tuple.uncurry($756($757));
                      };
                  })())(z)(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));
              };
          };
      },
      foldrWithIndex: function (f) {
          return function (z) {
              return function (m) {
                  return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(f))(z)(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));
              };
          };
      },
      foldMapWithIndex: function (dictMonoid) {
          return function (f) {
              return function (m) {
                  return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(Data_Tuple.uncurry(f))(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));
              };
          };
      },
      Foldable0: function () {
          return foldableMap;
      }
  };
  var alter = function (dictOrd) {
      return function (f) {
          return function (k) {
              return function (m) {
                  var v = f(lookup(dictOrd)(k)(m));
                  if (v instanceof Data_Maybe.Nothing) {
                      return $$delete(dictOrd)(k)(m);
                  };
                  if (v instanceof Data_Maybe.Just) {
                      return insert(dictOrd)(k)(v.value0)(m);
                  };
                  throw new Error("Failed pattern match at Data.Map.Internal (line 563, column 15 - line 565, column 25): " + [ v.constructor.name ]);
              };
          };
      };
  };
  var unionWith = function (dictOrd) {
      return function (f) {
          return function (m1) {
              return function (m2) {
                  var go = function (m) {
                      return function (v) {
                          return alter(dictOrd)((function () {
                              var $764 = Data_Maybe.maybe(v.value1)(f(v.value1));
                              return function ($765) {
                                  return Data_Maybe.Just.create($764($765));
                              };
                          })())(v.value0)(m);
                      };
                  };
                  return Data_Foldable.foldl(Data_List_Types.foldableList)(go)(m2)(toUnfoldable(Data_List_Types.unfoldableList)(m1));
              };
          };
      };
  };
  var union = function (dictOrd) {
      return unionWith(dictOrd)(Data_Function["const"]);
  };
  exports["empty"] = empty;
  exports["singleton"] = singleton;
  exports["insert"] = insert;
  exports["lookup"] = lookup;
  exports["fromFoldable"] = fromFoldable;
  exports["toUnfoldable"] = toUnfoldable;
  exports["delete"] = $$delete;
  exports["keys"] = keys;
  exports["union"] = union;
  exports["functorMap"] = functorMap;
  exports["foldableWithIndexMap"] = foldableWithIndexMap;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.Set"] = $PS["Data.Set"] || {};
  var exports = $PS["Data.Set"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_List = $PS["Data.List"];
  var Data_Map_Internal = $PS["Data.Map.Internal"];
  var Data_Unit = $PS["Data.Unit"];
  var union = function (dictOrd) {
      return function (v) {
          return function (v1) {
              return Data_Map_Internal.union(dictOrd)(v)(v1);
          };
      };
  };
  var toList = function (v) {
      return Data_Map_Internal.keys(v);
  };
  var toUnfoldable = function (dictUnfoldable) {
      var $70 = Data_List.toUnfoldable(dictUnfoldable);
      return function ($71) {
          return $70(toList($71));
      };
  };
  var semigroupSet = function (dictOrd) {
      return {
          append: union(dictOrd)
      };
  };
  var insert = function (dictOrd) {
      return function (a) {
          return function (v) {
              return Data_Map_Internal.insert(dictOrd)(a)(Data_Unit.unit)(v);
          };
      };
  };
  var empty = Data_Map_Internal.empty;
  var fromFoldable = function (dictFoldable) {
      return function (dictOrd) {
          return Data_Foldable.foldl(dictFoldable)(function (m) {
              return function (a) {
                  return insert(dictOrd)(a)(m);
              };
          })(empty);
      };
  };
  exports["fromFoldable"] = fromFoldable;
  exports["toUnfoldable"] = toUnfoldable;
  exports["empty"] = empty;
  exports["semigroupSet"] = semigroupSet;
})(PS);
(function(exports) {
  "use strict";

  function lengthImpl (str) {
    return Array.from(str).length;
  }

  function padEndPrimeImpl (targetLength, str) {
    return str.padEnd(targetLength);
  }                                                      
  exports.lengthImpl                 = lengthImpl;        
  exports.padEndPrimeImpl            = padEndPrimeImpl;
})(PS["Data.String.Utils"] = PS["Data.String.Utils"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Data.String.Utils"] = $PS["Data.String.Utils"] || {};
  var exports = $PS["Data.String.Utils"];
  var $foreign = $PS["Data.String.Utils"];
  var Data_String_CodePoints = $PS["Data.String.CodePoints"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var padEnd$prime = function (n) {
      return function (s) {
          return $foreign.padEndPrimeImpl(n, s);
      };
  };
  var padEnd = function (n) {
      return function (s) {
          var numberOfCodeUnits = Data_String_CodeUnits.length(s);
          var numberOfCodePoints = Data_String_CodePoints.length(s);
          return padEnd$prime((n + numberOfCodeUnits | 0) - numberOfCodePoints | 0)(s);
      };
  };                                     
  var length = function () {
      return function (s) {
          return $foreign.lengthImpl(s);
      };
  };
  exports["padEnd"] = padEnd;
})(PS);
(function(exports) {
  /* globals setImmediate, clearImmediate, setTimeout, clearTimeout */
  /* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */
  "use strict";

  var Aff = function () {
    // A unique value for empty.
    var EMPTY = {};

    /*

  An awkward approximation. We elide evidence we would otherwise need in PS for
  efficiency sake.

  data Aff eff a
    = Pure a
    | Throw Error
    | Catch (Aff eff a) (Error -> Aff eff a)
    | Sync (Eff eff a)
    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))
    | forall b. Bind (Aff eff b) (b -> Aff eff a)
    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)
    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)
    | Sequential (ParAff aff a)

  */  
    var PURE    = "Pure";
    var THROW   = "Throw";
    var CATCH   = "Catch";
    var SYNC    = "Sync";
    var ASYNC   = "Async";
    var BIND    = "Bind";
    var BRACKET = "Bracket";
    var FORK    = "Fork";
    var SEQ     = "Sequential";

    /*

  data ParAff eff a
    = forall b. Map (b -> a) (ParAff eff b)
    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)
    | Alt (ParAff eff a) (ParAff eff a)
    | ?Par (Aff eff a)

  */  
    var MAP   = "Map";
    var APPLY = "Apply";
    var ALT   = "Alt";

    // Various constructors used in interpretation
    var CONS      = "Cons";      // Cons-list, for stacks
    var RESUME    = "Resume";    // Continue indiscriminately
    var RELEASE   = "Release";   // Continue with bracket finalizers
    var FINALIZER = "Finalizer"; // A non-interruptible effect
    var FINALIZED = "Finalized"; // Marker for finalization
    var FORKED    = "Forked";    // Reference to a forked fiber, with resumption stack
    var FIBER     = "Fiber";     // Actual fiber reference
    var THUNK     = "Thunk";     // Primed effect, ready to invoke

    function Aff(tag, _1, _2, _3) {
      this.tag = tag;
      this._1  = _1;
      this._2  = _2;
      this._3  = _3;
    }

    function AffCtr(tag) {
      var fn = function (_1, _2, _3) {
        return new Aff(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }

    function nonCanceler(error) {
      return new Aff(PURE, void 0);
    }

    function runEff(eff) {
      try {
        eff();
      } catch (error) {
        setTimeout(function () {
          throw error;
        }, 0);
      }
    }

    function runSync(left, right, eff) {
      try {
        return right(eff());
      } catch (error) {
        return left(error);
      }
    }

    function runAsync(left, eff, k) {
      try {
        return eff(k)();
      } catch (error) {
        k(left(error))();
        return nonCanceler;
      }
    }

    var Scheduler = function () {
      var limit    = 1024;
      var size     = 0;
      var ix       = 0;
      var queue    = new Array(limit);
      var draining = false;

      function drain() {
        var thunk;
        draining = true;
        while (size !== 0) {
          size--;
          thunk     = queue[ix];
          queue[ix] = void 0;
          ix        = (ix + 1) % limit;
          thunk();
        }
        draining = false;
      }

      return {
        isDraining: function () {
          return draining;
        },
        enqueue: function (cb) {
          var i, tmp;
          if (size === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }

          queue[(ix + size) % limit] = cb;
          size++;

          if (!draining) {
            drain();
          }
        }
      };
    }();

    function Supervisor(util) {
      var fibers  = {};
      var fiberId = 0;
      var count   = 0;

      return {
        register: function (fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function (result) {
              return function () {
                count--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count++;
        },
        isEmpty: function () {
          return count === 0;
        },
        killAll: function (killError, cb) {
          return function () {
            if (count === 0) {
              return cb();
            }

            var killCount = 0;
            var kills     = {};

            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function (result) {
                return function () {
                  delete kills[fid];
                  killCount--;
                  if (util.isLeft(result) && util.fromLeft(result)) {
                    setTimeout(function () {
                      throw util.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }

            for (var k in fibers) {
              if (fibers.hasOwnProperty(k)) {
                killCount++;
                kill(k);
              }
            }

            fibers  = {};
            fiberId = 0;
            count   = 0;

            return function (error) {
              return new Aff(SYNC, function () {
                for (var k in kills) {
                  if (kills.hasOwnProperty(k)) {
                    kills[k]();
                  }
                }
              });
            };
          };
        }
      };
    }

    // Fiber state machine
    var SUSPENDED   = 0; // Suspended, pending a join.
    var CONTINUE    = 1; // Interpret the next instruction.
    var STEP_BIND   = 2; // Apply the next bind.
    var STEP_RESULT = 3; // Handle potential failure from a result.
    var PENDING     = 4; // An async effect is running.
    var RETURN      = 5; // The current stack has returned.
    var COMPLETED   = 6; // The entire fiber has completed.

    function Fiber(util, supervisor, aff) {
      // Monotonically increasing tick, increased on each asynchronous turn.
      var runTick = 0;

      // The current branch of the state machine.
      var status = SUSPENDED;

      // The current point of interest for the state machine branch.
      var step      = aff;  // Successful step
      var fail      = null; // Failure step
      var interrupt = null; // Asynchronous interrupt

      // Stack of continuations for the current fiber.
      var bhead = null;
      var btail = null;

      // Stack of attempts and finalizers for error recovery. Every `Cons` is also
      // tagged with current `interrupt` state. We use this to track which items
      // should be ignored or evaluated as a result of a kill.
      var attempts = null;

      // A special state is needed for Bracket, because it cannot be killed. When
      // we enter a bracket acquisition or finalizer, we increment the counter,
      // and then decrement once complete.
      var bracketCount = 0;

      // Each join gets a new id so they can be revoked.
      var joinId  = 0;
      var joins   = null;
      var rethrow = true;

      // Each invocation of `run` requires a tick. When an asynchronous effect is
      // resolved, we must check that the local tick coincides with the fiber
      // tick before resuming. This prevents multiple async continuations from
      // accidentally resuming the same fiber. A common example may be invoking
      // the provided callback in `makeAff` more than once, but it may also be an
      // async effect resuming after the fiber was already cancelled.
      function run(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp       = null;
          result    = null;
          attempt   = null;

          switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step   = bhead(step);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail   = util.left(e);
              step   = null;
            }
            break;

          case STEP_RESULT:
            if (util.isLeft(step)) {
              status = RETURN;
              fail   = step;
              step   = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step   = util.fromRight(step);
            }
            break;

          case CONTINUE:
            switch (step.tag) {
            case BIND:
              if (bhead) {
                btail = new Aff(CONS, bhead, btail);
              }
              bhead  = step._2;
              status = CONTINUE;
              step   = step._1;
              break;

            case PURE:
              if (bhead === null) {
                status = RETURN;
                step   = util.right(step._1);
              } else {
                status = STEP_BIND;
                step   = step._1;
              }
              break;

            case SYNC:
              status = STEP_RESULT;
              step   = runSync(util.left, util.right, step._1);
              break;

            case ASYNC:
              status = PENDING;
              step   = runAsync(util.left, step._1, function (result) {
                return function () {
                  if (runTick !== localRunTick) {
                    return;
                  }
                  runTick++;
                  Scheduler.enqueue(function () {
                    // It's possible to interrupt the fiber between enqueuing and
                    // resuming, so we need to check that the runTick is still
                    // valid.
                    if (runTick !== localRunTick + 1) {
                      return;
                    }
                    status = STEP_RESULT;
                    step   = result;
                    run(runTick);
                  });
                };
              });
              return;

            case THROW:
              status = RETURN;
              fail   = util.left(step._1);
              step   = null;
              break;

            // Enqueue the Catch so that we can call the error handler later on
            // in case of an exception.
            case CATCH:
              if (bhead === null) {
                attempts = new Aff(CONS, step, attempts, interrupt);
              } else {
                attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);
              }
              bhead    = null;
              btail    = null;
              status   = CONTINUE;
              step     = step._1;
              break;

            // Enqueue the Bracket so that we can call the appropriate handlers
            // after resource acquisition.
            case BRACKET:
              bracketCount++;
              if (bhead === null) {
                attempts = new Aff(CONS, step, attempts, interrupt);
              } else {
                attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);
              }
              bhead  = null;
              btail  = null;
              status = CONTINUE;
              step   = step._1;
              break;

            case FORK:
              status = STEP_RESULT;
              tmp    = Fiber(util, supervisor, step._2);
              if (supervisor) {
                supervisor.register(tmp);
              }
              if (step._1) {
                tmp.run();
              }
              step = util.right(tmp);
              break;

            case SEQ:
              status = CONTINUE;
              step   = sequential(util, supervisor, step._1);
              break;
            }
            break;

          case RETURN:
            bhead = null;
            btail = null;
            // If the current stack has returned, and we have no other stacks to
            // resume or finalizers to run, the fiber has halted and we can
            // invoke all join callbacks. Otherwise we need to resume.
            if (attempts === null) {
              status = COMPLETED;
              step   = interrupt || fail || step;
            } else {
              // The interrupt status for the enqueued item.
              tmp      = attempts._3;
              attempt  = attempts._1;
              attempts = attempts._2;

              switch (attempt.tag) {
              // We cannot recover from an unmasked interrupt. Otherwise we should
              // continue stepping, or run the exception handler if an exception
              // was raised.
              case CATCH:
                // We should compare the interrupt status as well because we
                // only want it to apply if there has been an interrupt since
                // enqueuing the catch.
                if (interrupt && interrupt !== tmp && bracketCount === 0) {
                  status = RETURN;
                } else if (fail) {
                  status = CONTINUE;
                  step   = attempt._2(util.fromLeft(fail));
                  fail   = null;
                }
                break;

              // We cannot resume from an unmasked interrupt or exception.
              case RESUME:
                // As with Catch, we only want to ignore in the case of an
                // interrupt since enqueing the item.
                if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {
                  status = RETURN;
                } else {
                  bhead  = attempt._1;
                  btail  = attempt._2;
                  status = STEP_BIND;
                  step   = util.fromRight(step);
                }
                break;

              // If we have a bracket, we should enqueue the handlers,
              // and continue with the success branch only if the fiber has
              // not been interrupted. If the bracket acquisition failed, we
              // should not run either.
              case BRACKET:
                bracketCount--;
                if (fail === null) {
                  result   = util.fromRight(step);
                  // We need to enqueue the Release with the same interrupt
                  // status as the Bracket that is initiating it.
                  attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);
                  // We should only coninue as long as the interrupt status has not changed or
                  // we are currently within a non-interruptable finalizer.
                  if (interrupt === tmp || bracketCount > 0) {
                    status = CONTINUE;
                    step   = attempt._3(result);
                  }
                }
                break;

              // Enqueue the appropriate handler. We increase the bracket count
              // because it should not be cancelled.
              case RELEASE:
                attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);
                status   = CONTINUE;
                // It has only been killed if the interrupt status has changed
                // since we enqueued the item, and the bracket count is 0. If the
                // bracket count is non-zero then we are in a masked state so it's
                // impossible to be killed.
                if (interrupt && interrupt !== tmp && bracketCount === 0) {
                  step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                } else if (fail) {
                  step = attempt._1.failed(util.fromLeft(fail))(attempt._2);
                } else {
                  step = attempt._1.completed(util.fromRight(step))(attempt._2);
                }
                fail = null;
                bracketCount++;
                break;

              case FINALIZER:
                bracketCount++;
                attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);
                status   = CONTINUE;
                step     = attempt._1;
                break;

              case FINALIZED:
                bracketCount--;
                status = RETURN;
                step   = attempt._1;
                fail   = attempt._2;
                break;
              }
            }
            break;

          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step));
              }
            }
            joins = null;
            // If we have an interrupt and a fail, then the thread threw while
            // running finalizers. This should always rethrow in a fresh stack.
            if (interrupt && fail) {
              setTimeout(function () {
                throw util.fromLeft(fail);
              }, 0);
            // If we have an unhandled exception, and no other fiber has joined
            // then we need to throw the exception in a fresh stack.
            } else if (util.isLeft(step) && rethrow) {
              setTimeout(function () {
                // Guard on reathrow because a completely synchronous fiber can
                // still have an observer which was added after-the-fact.
                if (rethrow) {
                  throw util.fromLeft(step);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING: return;
          }
        }
      }

      function onComplete(join) {
        return function () {
          if (status === COMPLETED) {
            rethrow = rethrow && join.rethrow;
            join.handler(step)();
            return function () {};
          }

          var jid    = joinId++;
          joins      = joins || {};
          joins[jid] = join;

          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }

      function kill(error, cb) {
        return function () {
          if (status === COMPLETED) {
            cb(util.right(void 0))();
            return function () {};
          }

          var canceler = onComplete({
            rethrow: false,
            handler: function (/* unused */) {
              return cb(util.right(void 0));
            }
          })();

          switch (status) {
          case SUSPENDED:
            interrupt = util.left(error);
            status    = COMPLETED;
            step      = interrupt;
            run(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);
              }
              status   = RETURN;
              step     = null;
              fail     = null;
              run(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step   = null;
              fail   = null;
            }
          }

          return canceler;
        };
      }

      function join(cb) {
        return function () {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run(runTick);
          }
          return canceler;
        };
      }

      return {
        kill: kill,
        join: join,
        onComplete: onComplete,
        isSuspended: function () {
          return status === SUSPENDED;
        },
        run: function () {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function () {
                run(runTick);
              });
            } else {
              run(runTick);
            }
          }
        }
      };
    }

    function runPar(util, supervisor, par, cb) {
      // Table of all forked fibers.
      var fiberId   = 0;
      var fibers    = {};

      // Table of currently running cancelers, as a product of `Alt` behavior.
      var killId    = 0;
      var kills     = {};

      // Error used for early cancelation on Alt branches.
      var early     = new Error("[ParAff] Early exit");

      // Error used to kill the entire tree.
      var interrupt = null;

      // The root pointer of the tree.
      var root      = EMPTY;

      // Walks a tree, invoking all the cancelers. Returns the table of pending
      // cancellation fibers.
      function kill(error, par, cb) {
        var step  = par;
        var head  = null;
        var tail  = null;
        var count = 0;
        var kills = {};
        var tmp, kid;

        loop: while (true) {
          tmp = null;

          switch (step.tag) {
          case FORKED:
            if (step._3 === EMPTY) {
              tmp = fibers[step._1];
              kills[count++] = tmp.kill(error, function (result) {
                return function () {
                  count--;
                  if (count === 0) {
                    cb(result)();
                  }
                };
              });
            }
            // Terminal case.
            if (head === null) {
              break loop;
            }
            // Go down the right side of the tree.
            step = head._2;
            if (tail === null) {
              head = null;
            } else {
              head = tail._1;
              tail = tail._2;
            }
            break;
          case MAP:
            step = step._2;
            break;
          case APPLY:
          case ALT:
            if (head) {
              tail = new Aff(CONS, head, tail);
            }
            head = step;
            step = step._1;
            break;
          }
        }

        if (count === 0) {
          cb(util.right(void 0))();
        } else {
          // Run the cancelation effects. We alias `count` because it's mutable.
          kid = 0;
          tmp = count;
          for (; kid < tmp; kid++) {
            kills[kid] = kills[kid]();
          }
        }

        return kills;
      }

      // When a fiber resolves, we need to bubble back up the tree with the
      // result, computing the applicative nodes.
      function join(result, head, tail) {
        var fail, step, lhs, rhs, tmp, kid;

        if (util.isLeft(result)) {
          fail = result;
          step = null;
        } else {
          step = result;
          fail = null;
        }

        loop: while (true) {
          lhs = null;
          rhs = null;
          tmp = null;
          kid = null;

          // We should never continue if the entire tree has been interrupted.
          if (interrupt !== null) {
            return;
          }

          // We've made it all the way to the root of the tree, which means
          // the tree has fully evaluated.
          if (head === null) {
            cb(fail || step)();
            return;
          }

          // The tree has already been computed, so we shouldn't try to do it
          // again. This should never happen.
          // TODO: Remove this?
          if (head._3 !== EMPTY) {
            return;
          }

          switch (head.tag) {
          case MAP:
            if (fail === null) {
              head._3 = util.right(head._1(util.fromRight(step)));
              step    = head._3;
            } else {
              head._3 = fail;
            }
            break;
          case APPLY:
            lhs = head._1._3;
            rhs = head._2._3;
            // If we have a failure we should kill the other side because we
            // can't possible yield a result anymore.
            if (fail) {
              head._3 = fail;
              tmp     = true;
              kid     = killId++;

              kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {
                return function () {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join(fail, null, null);
                  } else {
                    join(fail, tail._1, tail._2);
                  }
                };
              });

              if (tmp) {
                tmp = false;
                return;
              }
            } else if (lhs === EMPTY || rhs === EMPTY) {
              // We can only proceed if both sides have resolved.
              return;
            } else {
              step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
              head._3 = step;
            }
            break;
          case ALT:
            lhs = head._1._3;
            rhs = head._2._3;
            // We can only proceed if both have resolved or we have a success
            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
              return;
            }
            // If both sides resolve with an error, we should continue with the
            // first error
            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
              fail    = step === lhs ? rhs : lhs;
              step    = null;
              head._3 = fail;
            } else {
              head._3 = step;
              tmp     = true;
              kid     = killId++;
              // Once a side has resolved, we need to cancel the side that is still
              // pending before we can continue.
              kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {
                return function () {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join(step, null, null);
                  } else {
                    join(step, tail._1, tail._2);
                  }
                };
              });

              if (tmp) {
                tmp = false;
                return;
              }
            }
            break;
          }

          if (tail === null) {
            head = null;
          } else {
            head = tail._1;
            tail = tail._2;
          }
        }
      }

      function resolve(fiber) {
        return function (result) {
          return function () {
            delete fibers[fiber._1];
            fiber._3 = result;
            join(result, fiber._2._1, fiber._2._2);
          };
        };
      }

      // Walks the applicative tree, substituting non-applicative nodes with
      // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot
      // as a mutable slot for memoization. In an unresolved state, the `_3`
      // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk
      // the left side first, because both operations are left-associative. As
      // we `RETURN` from those branches, we then walk the right side.
      function run() {
        var status = CONTINUE;
        var step   = par;
        var head   = null;
        var tail   = null;
        var tmp, fid;

        loop: while (true) {
          tmp = null;
          fid = null;

          switch (status) {
          case CONTINUE:
            switch (step.tag) {
            case MAP:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(MAP, step._1, EMPTY, EMPTY);
              step = step._2;
              break;
            case APPLY:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(APPLY, EMPTY, step._2, EMPTY);
              step = step._1;
              break;
            case ALT:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(ALT, EMPTY, step._2, EMPTY);
              step = step._1;
              break;
            default:
              // When we hit a leaf value, we suspend the stack in the `FORKED`.
              // When the fiber resolves, it can bubble back up the tree.
              fid    = fiberId++;
              status = RETURN;
              tmp    = step;
              step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);
              tmp    = Fiber(util, supervisor, tmp);
              tmp.onComplete({
                rethrow: false,
                handler: resolve(step)
              })();
              fibers[fid] = tmp;
              if (supervisor) {
                supervisor.register(tmp);
              }
            }
            break;
          case RETURN:
            // Terminal case, we are back at the root.
            if (head === null) {
              break loop;
            }
            // If we are done with the right side, we need to continue down the
            // left. Otherwise we should continue up the stack.
            if (head._1 === EMPTY) {
              head._1 = step;
              status  = CONTINUE;
              step    = head._2;
              head._2 = EMPTY;
            } else {
              head._2 = step;
              step    = head;
              if (tail === null) {
                head  = null;
              } else {
                head  = tail._1;
                tail  = tail._2;
              }
            }
          }
        }

        // Keep a reference to the tree root so it can be cancelled.
        root = step;

        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }

      // Cancels the entire tree. If there are already subtrees being canceled,
      // we need to first cancel those joins. We will then add fresh joins for
      // all pending branches including those that were in the process of being
      // canceled.
      function cancel(error, cb) {
        interrupt = util.left(error);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }

        kills = null;
        var newKills = kill(error, root, cb);

        return function (killError) {
          return new Aff(ASYNC, function (killCb) {
            return function () {
              for (var kid in newKills) {
                if (newKills.hasOwnProperty(kid)) {
                  newKills[kid]();
                }
              }
              return nonCanceler;
            };
          });
        };
      }

      run();

      return function (killError) {
        return new Aff(ASYNC, function (killCb) {
          return function () {
            return cancel(killError, killCb);
          };
        });
      };
    }

    function sequential(util, supervisor, par) {
      return new Aff(ASYNC, function (cb) {
        return function () {
          return runPar(util, supervisor, par, cb);
        };
      });
    }

    Aff.EMPTY       = EMPTY;
    Aff.Pure        = AffCtr(PURE);
    Aff.Throw       = AffCtr(THROW);
    Aff.Catch       = AffCtr(CATCH);
    Aff.Sync        = AffCtr(SYNC);
    Aff.Async       = AffCtr(ASYNC);
    Aff.Bind        = AffCtr(BIND);
    Aff.Bracket     = AffCtr(BRACKET);
    Aff.Fork        = AffCtr(FORK);
    Aff.Seq         = AffCtr(SEQ);
    Aff.ParMap      = AffCtr(MAP);
    Aff.ParApply    = AffCtr(APPLY);
    Aff.ParAlt      = AffCtr(ALT);
    Aff.Fiber       = Fiber;
    Aff.Supervisor  = Supervisor;
    Aff.Scheduler   = Scheduler;
    Aff.nonCanceler = nonCanceler;

    return Aff;
  }();

  exports._pure = Aff.Pure;

  exports._map = function (f) {
    return function (aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f(aff._1));
      } else {
        return Aff.Bind(aff, function (value) {
          return Aff.Pure(f(value));
        });
      }
    };
  };

  exports._bind = function (aff) {
    return function (k) {
      return Aff.Bind(aff, k);
    };
  };

  exports._liftEffect = Aff.Sync;

  exports.makeAff = Aff.Async;

  exports._makeFiber = function (util, aff) {
    return function () {
      return Aff.Fiber(util, null, aff);
    };
  };
})(PS["Effect.Aff"] = PS["Effect.Aff"] || {});
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Monad = $PS["Control.Monad"];                  
  var monadEffect = {
      Applicative0: function () {
          return applicativeEffect;
      },
      Bind1: function () {
          return bindEffect;
      }
  };
  var bindEffect = {
      bind: $foreign.bindE,
      Apply0: function () {
          return applyEffect;
      }
  };
  var applyEffect = {
      apply: Control_Monad.ap(monadEffect),
      Functor0: function () {
          return functorEffect;
      }
  };
  var applicativeEffect = {
      pure: $foreign.pureE,
      Apply0: function () {
          return applyEffect;
      }
  };
  var functorEffect = {
      map: Control_Applicative.liftA1(applicativeEffect)
  };
  exports["functorEffect"] = functorEffect;
})(PS);
(function(exports) {
  "use strict";

  // module Partial.Unsafe

  exports._unsafePartial = function (f) {
    return f();
  };
})(PS["Partial.Unsafe"] = PS["Partial.Unsafe"] || {});
(function(exports) {
  "use strict";

  // module Partial

  exports._crashWith = function (msg) {
    throw new Error(msg);
  };
})(PS["Partial"] = PS["Partial"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Partial"] = $PS["Partial"] || {};
  var exports = $PS["Partial"];
  var $foreign = $PS["Partial"];         
  var crashWith = function () {
      return $foreign["_crashWith"];
  };
  exports["crashWith"] = crashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Partial.Unsafe"] = $PS["Partial.Unsafe"] || {};
  var exports = $PS["Partial.Unsafe"];
  var $foreign = $PS["Partial.Unsafe"];
  var Partial = $PS["Partial"];                
  var unsafePartial = $foreign["_unsafePartial"];
  var unsafeCrashWith = function (msg) {
      return unsafePartial(function () {
          return Partial.crashWith()(msg);
      });
  };
  exports["unsafeCrashWith"] = unsafeCrashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Effect.Aff"] = $PS["Effect.Aff"] || {};
  var exports = $PS["Effect.Aff"];
  var $foreign = $PS["Effect.Aff"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Either = $PS["Data.Either"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Partial_Unsafe = $PS["Partial.Unsafe"];
  var functorAff = {
      map: $foreign["_map"]
  };                                    
  var ffiUtil = (function () {
      var unsafeFromRight = function (v) {
          if (v instanceof Data_Either.Right) {
              return v.value0;
          };
          if (v instanceof Data_Either.Left) {
              return Partial_Unsafe.unsafeCrashWith("unsafeFromRight: Left");
          };
          throw new Error("Failed pattern match at Effect.Aff (line 404, column 21 - line 406, column 54): " + [ v.constructor.name ]);
      };
      var unsafeFromLeft = function (v) {
          if (v instanceof Data_Either.Left) {
              return v.value0;
          };
          if (v instanceof Data_Either.Right) {
              return Partial_Unsafe.unsafeCrashWith("unsafeFromLeft: Right");
          };
          throw new Error("Failed pattern match at Effect.Aff (line 399, column 20 - line 401, column 54): " + [ v.constructor.name ]);
      };
      var isLeft = function (v) {
          if (v instanceof Data_Either.Left) {
              return true;
          };
          if (v instanceof Data_Either.Right) {
              return false;
          };
          throw new Error("Failed pattern match at Effect.Aff (line 394, column 12 - line 396, column 20): " + [ v.constructor.name ]);
      };
      return {
          isLeft: isLeft,
          fromLeft: unsafeFromLeft,
          fromRight: unsafeFromRight,
          left: Data_Either.Left.create,
          right: Data_Either.Right.create
      };
  })();
  var makeFiber = function (aff) {
      return $foreign["_makeFiber"](ffiUtil, aff);
  };
  var launchAff = function (aff) {
      return function __do() {
          var fiber = makeFiber(aff)();
          fiber.run();
          return fiber;
      };
  };
  var launchAff_ = (function () {
      var $40 = Data_Functor["void"](Effect.functorEffect);
      return function ($41) {
          return $40(launchAff($41));
      };
  })();
  var monadAff = {
      Applicative0: function () {
          return applicativeAff;
      },
      Bind1: function () {
          return bindAff;
      }
  };
  var bindAff = {
      bind: $foreign["_bind"],
      Apply0: function () {
          return applyAff;
      }
  };
  var applyAff = {
      apply: Control_Monad.ap(monadAff),
      Functor0: function () {
          return functorAff;
      }
  };
  var applicativeAff = {
      pure: $foreign["_pure"],
      Apply0: function () {
          return applyAff;
      }
  };
  var monadEffectAff = {
      liftEffect: $foreign["_liftEffect"],
      Monad0: function () {
          return monadAff;
      }
  };
  var nonCanceler = Data_Function["const"](Control_Applicative.pure(applicativeAff)(Data_Unit.unit));
  exports["launchAff_"] = launchAff_;
  exports["nonCanceler"] = nonCanceler;
  exports["applicativeAff"] = applicativeAff;
  exports["bindAff"] = bindAff;
  exports["monadEffectAff"] = monadEffectAff;
  exports["makeAff"] = $foreign.makeAff;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Effect.Class"] = $PS["Effect.Class"] || {};
  var exports = $PS["Effect.Class"];
  var liftEffect = function (dict) {
      return dict.liftEffect;
  };
  exports["liftEffect"] = liftEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
    };
  };
})(PS["Effect.Console"] = PS["Effect.Console"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Effect.Console"] = $PS["Effect.Console"] || {};
  var exports = $PS["Effect.Console"];
  var $foreign = $PS["Effect.Console"];
  exports["log"] = $foreign.log;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Node.Encoding"] = $PS["Node.Encoding"] || {};
  var exports = $PS["Node.Encoding"];    
  var ASCII = (function () {
      function ASCII() {

      };
      ASCII.value = new ASCII();
      return ASCII;
  })();
  var UTF8 = (function () {
      function UTF8() {

      };
      UTF8.value = new UTF8();
      return UTF8;
  })();
  var UTF16LE = (function () {
      function UTF16LE() {

      };
      UTF16LE.value = new UTF16LE();
      return UTF16LE;
  })();
  var UCS2 = (function () {
      function UCS2() {

      };
      UCS2.value = new UCS2();
      return UCS2;
  })();
  var Base64 = (function () {
      function Base64() {

      };
      Base64.value = new Base64();
      return Base64;
  })();
  var Latin1 = (function () {
      function Latin1() {

      };
      Latin1.value = new Latin1();
      return Latin1;
  })();
  var Binary = (function () {
      function Binary() {

      };
      Binary.value = new Binary();
      return Binary;
  })();
  var Hex = (function () {
      function Hex() {

      };
      Hex.value = new Hex();
      return Hex;
  })();
  var showEncoding = {
      show: function (v) {
          if (v instanceof ASCII) {
              return "ASCII";
          };
          if (v instanceof UTF8) {
              return "UTF8";
          };
          if (v instanceof UTF16LE) {
              return "UTF16LE";
          };
          if (v instanceof UCS2) {
              return "UCS2";
          };
          if (v instanceof Base64) {
              return "Base64";
          };
          if (v instanceof Latin1) {
              return "Latin1";
          };
          if (v instanceof Binary) {
              return "Binary";
          };
          if (v instanceof Hex) {
              return "Hex";
          };
          throw new Error("Failed pattern match at Node.Encoding (line 19, column 1 - line 27, column 23): " + [ v.constructor.name ]);
      }
  };
  exports["UTF8"] = UTF8;
  exports["showEncoding"] = showEncoding;
})(PS);
(function(exports) {
  "use strict";

  exports.handleCallbackImpl = function (left, right, f) {
    return function (err, value) {
      if (err) {
        f(left(err))();
      } else {
        f(right(value))();
      }
    };
  };
})(PS["Node.FS.Async"] = PS["Node.FS.Async"] || {});
(function(exports) {
  "use strict";

  exports.unsafePerformEffect = function (f) {
    return f();
  };
})(PS["Effect.Unsafe"] = PS["Effect.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Effect.Unsafe"] = $PS["Effect.Unsafe"] || {};
  var exports = $PS["Effect.Unsafe"];
  var $foreign = $PS["Effect.Unsafe"];
  exports["unsafePerformEffect"] = $foreign.unsafePerformEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.unsafeRequireFS = require("fs");
})(PS["Node.FS.Internal"] = PS["Node.FS.Internal"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Node.FS.Internal"] = $PS["Node.FS.Internal"] || {};
  var exports = $PS["Node.FS.Internal"];
  var $foreign = $PS["Node.FS.Internal"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];                
  var mkEffect = Unsafe_Coerce.unsafeCoerce;
  exports["mkEffect"] = mkEffect;
  exports["unsafeRequireFS"] = $foreign.unsafeRequireFS;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Node.FS.Async"] = $PS["Node.FS.Async"] || {};
  var exports = $PS["Node.FS.Async"];
  var $foreign = $PS["Node.FS.Async"];
  var Data_Either = $PS["Data.Either"];
  var Data_Show = $PS["Data.Show"];
  var Effect_Unsafe = $PS["Effect.Unsafe"];
  var Node_Encoding = $PS["Node.Encoding"];
  var Node_FS_Internal = $PS["Node.FS.Internal"];          
  var handleCallback = function (cb) {
      return $foreign.handleCallbackImpl(Data_Either.Left.create, Data_Either.Right.create, cb);
  };
  var fs = Node_FS_Internal.unsafeRequireFS;
  var readFile = function (file) {
      return function (cb) {
          return Node_FS_Internal.mkEffect(function (v) {
              return fs.readFile(file, {}, handleCallback(cb));
          });
      };
  };
  var readTextFile = function (encoding) {
      return function (file) {
          return function (cb) {
              return Node_FS_Internal.mkEffect(function (v) {
                  return fs.readFile(file, {
                      encoding: Data_Show.show(Node_Encoding.showEncoding)(encoding)
                  }, handleCallback(cb));
              });
          };
      };
  };
  var writeFile = function (file) {
      return function (buff) {
          return function (cb) {
              return Node_FS_Internal.mkEffect(function (v) {
                  return fs.writeFile(file, buff, {}, handleCallback(cb));
              });
          };
      };
  };
  var writeTextFile = function (encoding) {
      return function (file) {
          return function (buff) {
              return function (cb) {
                  return Node_FS_Internal.mkEffect(function (v) {
                      return fs.writeFile(file, buff, {
                          encoding: Data_Show.show(Node_Encoding.showEncoding)(encoding)
                      }, handleCallback(cb));
                  });
              };
          };
      };
  };
  var exists = function (file) {
      return function (cb) {
          return Node_FS_Internal.mkEffect(function (v) {
              return fs.exists(file, function (b) {
                  return Effect_Unsafe.unsafePerformEffect(cb(b));
              });
          });
      };
  };
  exports["readTextFile"] = readTextFile;
  exports["writeTextFile"] = writeTextFile;
  exports["exists"] = exists;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Node.FS.Aff"] = $PS["Node.FS.Aff"] || {};
  var exports = $PS["Node.FS.Aff"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Node_FS_Async = $PS["Node.FS.Async"];                
  var toAff = function (p) {
      return Effect_Aff.makeAff(function (k) {
          return Data_Functor.voidLeft(Effect.functorEffect)(p(k))(Effect_Aff.nonCanceler);
      });
  };                                        
  var toAff2 = function (f) {
      return function (a) {
          return function (b) {
              return toAff(f(a)(b));
          };
      };
  };                                              
  var toAff3 = function (f) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return toAff(f(a)(b)(c));
              };
          };
      };
  };                                        
  var writeTextFile = toAff3(Node_FS_Async.writeTextFile);
  var readTextFile = toAff2(Node_FS_Async.readTextFile);
  var exists = function (file) {
      return Effect_Aff.makeAff(function (k) {
          return Data_Functor.voidLeft(Effect.functorEffect)(Node_FS_Async.exists(file)((function () {
              var $0 = Control_Applicative.pure(Data_Either.applicativeEither);
              return function ($1) {
                  return k($0($1));
              };
          })()))(Effect_Aff.nonCanceler);
      });
  };
  exports["readTextFile"] = readTextFile;
  exports["writeTextFile"] = writeTextFile;
  exports["exists"] = exists;
})(PS);
(function($PS) {
  "use strict";
  $PS["Application"] = $PS["Application"] || {};
  var exports = $PS["Application"];
  var CLI = $PS["CLI"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad_Rec_Class = $PS["Control.Monad.Rec.Class"];
  var Data_Argonaut_Decode_Class = $PS["Data.Argonaut.Decode.Class"];
  var Data_Argonaut_Decode_Error = $PS["Data.Argonaut.Decode.Error"];
  var Data_Argonaut_Parser = $PS["Data.Argonaut.Parser"];
  var Data_Array = $PS["Data.Array"];
  var Data_Bifunctor = $PS["Data.Bifunctor"];
  var Data_Either = $PS["Data.Either"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_FoldableWithIndex = $PS["Data.FoldableWithIndex"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Map_Internal = $PS["Data.Map.Internal"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Set = $PS["Data.Set"];
  var Data_Show = $PS["Data.Show"];
  var Data_String_CodeUnits = $PS["Data.String.CodeUnits"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_String_Utils = $PS["Data.String.Utils"];
  var Data_TraversableWithIndex = $PS["Data.TraversableWithIndex"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Data_Unfoldable = $PS["Data.Unfoldable"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var Effect_Console = $PS["Effect.Console"];
  var Foreign_Object = $PS["Foreign.Object"];
  var Node_Encoding = $PS["Node.Encoding"];
  var Node_FS_Aff = $PS["Node.FS.Aff"];
  var Partial_Unsafe = $PS["Partial.Unsafe"];                
  var removeFinishedDeps = function (depsToRemove) {
      return function (packageMap) {
          var removedKeys = Data_Array.foldl(Data_Function.flip(Data_Map_Internal["delete"](Data_Ord.ordString)))(packageMap)(depsToRemove);
          return Data_Functor.mapFlipped(Data_Map_Internal.functorMap)(removedKeys)(function (packageMeta) {
              return {
                  dependencies: Data_Array.difference(Data_Eq.eqString)(packageMeta.dependencies)(depsToRemove),
                  repo: packageMeta.repo,
                  version: packageMeta.version
              };
          });
      };
  };
  var mkSortedPackageArray = (function () {
      var $62 = Data_Array.sortBy(function (l) {
          return function (r) {
              var v = Data_Ord.compare(Data_Ord.ordInt)(l.depCount)(r.depCount);
              if (v instanceof Data_Ordering.EQ) {
                  return Data_Ord.compare(Data_Ord.ordString)(l["package"])(r["package"]);
              };
              return v;
          };
      });
      var $63 = Data_Functor.map(Data_Functor.functorArray)(function (v) {
          var depArr = Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value1.dependencies);
          return {
              "package": v.value0,
              meta: {
                  dependencies: Data_Array.sort(Data_Ord.ordString)(depArr),
                  repo: v.value1.repo,
                  version: v.value1.version
              },
              depCount: Data_Array.length(depArr)
          };
      });
      var $64 = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray);
      return function ($65) {
          return $62($63($64($65)));
      };
  })();
  var mkOrderedContent = function (arr) {
      var maxPartLength = function (acc) {
          return function (r) {
              return {
                  dep: Data_Ord.max(Data_Ord.ordInt)(acc.dep)(Data_String_CodeUnits.length(Data_Show.show(Data_Show.showInt)(r.depCount))),
                  "package": Data_Ord.max(Data_Ord.ordInt)(acc["package"])(Data_String_CodeUnits.length(r["package"])),
                  repo: Data_Ord.max(Data_Ord.ordInt)(acc.repo)(Data_String_CodeUnits.length(r.meta.repo))
              };
          };
      };
      var maxLength = Data_Array.foldl(maxPartLength)({
          dep: 0,
          "package": 0,
          repo: 0
      })(arr);
      var buildLine = function (acc) {
          return function (r) {
              var repo = Data_String_Utils.padEnd(maxLength.repo)(r.meta.repo);
              var $$package = Data_String_Utils.padEnd(maxLength["package"])(r["package"]);
              var depCount = Data_String_Utils.padEnd(maxLength.dep)(Data_Show.show(Data_Show.showInt)(r.depCount));
              var nextLine = depCount + (" " + ($$package + (" " + (repo + (" " + Data_Show.show(Data_Show.showArray(Data_Show.showString))(r.meta.dependencies))))));
              return {
                  init: false,
                  str: (function () {
                      if (acc.init) {
                          return nextLine;
                      };
                      return acc.str + ("\x0a" + nextLine);
                  })()
              };
          };
      };
      var foldResult = Data_Array.foldl(buildLine)({
          init: true,
          str: ""
      })(arr);
      return foldResult.str;
  };

  // runSpagoFiles :: SpagoFilesOptions -> Map String (PackageMeta) -> Aff Unit
  // runSpagoFiles { directory, whitelist } allDepsKnown = do
  //   dirExists <- exists directory
  //   unless dirExists $ mkdirRecursive directory
  //   let
  //     onlyDesiredPackages = case whitelist of
  //       Nothing -> allDepsKnown
  //       Just packagesToInclude -> do
  //         let isDesiredPackage p = isJust (p `elemIndex` packagesToInclude)
  //         filterKeys isDesiredPackage allDepsKnown
  //     sortedPackageArray = mkSortedPackageArray onlyDesiredPackages
  //   ref <- liftEffect $ Ref.new Nil
  //   for_ sortedPackageArray \rec -> do
  //     let
  //       filePath = directory <> "/" <> rec.package <> ".dhall"
  //       fileContent = mkSpagoDhall rec
  //     fileExists <- exists filePath
  //     when (fileExists && not env.force) do
  //       liftEffect $ log $
  //         "spago.dhall file for package '" <> rec.package <>
  //           "' already \
  //           \exists. Skipping this file."
  //     writeTextFile UTF8 filePath fileContent
  //   liftEffect do
  //     list <- Ref.read ref
  //     unless (List.null list) do
  //       log $
  //         "The following packages did not have a \
  //         \`spago.dhall` file created because they \
  //         \already exist. To overwrite them, use the \
  //         \`--force` flag."
  //       let content = intercalate ", " list
  //       log content
  var findAllTransitiveDeps = function (packageMap) {
      var getDeps = function (packageName) {
          return Data_Maybe.fromMaybe(Data_Set.empty)(Data_Functor.map(Data_Maybe.functorMaybe)((function () {
              var $66 = Data_Set.fromFoldable(Data_Foldable.foldableArray)(Data_Ord.ordString);
              return function ($67) {
                  return $66((function (v) {
                      return v.dependencies;
                  })($67));
              };
          })())(Data_Map_Internal.lookup(Data_Ord.ordString)(packageName)(packageMap)));
      };
      var go = function (v) {
          var v1 = Data_Array.uncons(v.remaining);
          if (v1 instanceof Data_Maybe.Nothing) {
              var newMeta = {
                  dependencies: v.allDeps,
                  repo: v.packageMeta.repo,
                  version: v.packageMeta.version
              };
              return new Control_Monad_Rec_Class.Done({
                  deps: v.allDeps,
                  updatedMap: Data_Map_Internal.union(Data_Ord.ordString)(v.mapSoFar)(Data_Map_Internal.singleton(v.packageName)(newMeta))
              });
          };
          if (v1 instanceof Data_Maybe.Just) {
              var v2 = Data_Map_Internal.lookup(Data_Ord.ordString)(v.packageName)(v.mapSoFar);
              if (v2 instanceof Data_Maybe.Just) {
                  return new Control_Monad_Rec_Class.Loop({
                      allDeps: Data_Semigroup.append(Data_Set.semigroupSet(Data_Ord.ordString))(v.allDeps)(v2.value0.dependencies),
                      remaining: v1.value0.tail,
                      mapSoFar: v.mapSoFar,
                      packageMeta: v.packageMeta,
                      packageName: v.packageName
                  });
              };
              if (v2 instanceof Data_Maybe.Nothing) {
                  var v3 = Data_Map_Internal.lookup(Data_Ord.ordString)(v1.value0.head)(packageMap);
                  if (v3 instanceof Data_Maybe.Nothing) {
                      return Partial_Unsafe.unsafeCrashWith("The impossible happened. `packageMap` does not contain the package '" + (v.packageName + "'."));
                  };
                  if (v3 instanceof Data_Maybe.Just) {
                      var v4 = getDepsRecursively(v1.value0.head)(v3.value0)(v.mapSoFar);
                      return new Control_Monad_Rec_Class.Loop({
                          allDeps: Data_Semigroup.append(Data_Set.semigroupSet(Data_Ord.ordString))(v.allDeps)(v4.deps),
                          mapSoFar: v4.updatedMap,
                          remaining: v1.value0.tail,
                          packageMeta: v.packageMeta,
                          packageName: v.packageName
                      });
                  };
                  throw new Error("Failed pattern match at Application (line 141, column 20 - line 150, column 98): " + [ v3.constructor.name ]);
              };
              throw new Error("Failed pattern match at Application (line 139, column 7 - line 150, column 98): " + [ v2.constructor.name ]);
          };
          throw new Error("Failed pattern match at Application (line 132, column 73 - line 150, column 98): " + [ v1.constructor.name ]);
      };
      var getDepsRecursively = function (packageName) {
          return function (packageMeta) {
              return function (mapSoFar) {
                  var direct = getDeps(packageName);
                  return Control_Monad_Rec_Class.tailRec(go)({
                      packageName: packageName,
                      packageMeta: packageMeta,
                      mapSoFar: mapSoFar,
                      allDeps: direct,
                      remaining: Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(direct)
                  });
              };
          };
      };
      var buildMap = function (packageName) {
          return function (mapSoFar) {
              return function (packageMeta) {
                  var v = Data_Map_Internal.lookup(Data_Ord.ordString)(packageName)(mapSoFar);
                  if (v instanceof Data_Maybe.Just) {
                      return mapSoFar;
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      var v1 = getDepsRecursively(packageName)(packageMeta)(mapSoFar);
                      return v1.updatedMap;
                  };
                  throw new Error("Failed pattern match at Application (line 113, column 5 - line 119, column 21): " + [ v.constructor.name ]);
              };
          };
      };
      return Data_FoldableWithIndex.foldlWithIndex(Data_Map_Internal.foldableWithIndexMap)(buildMap)(Data_Map_Internal.empty)(packageMap);
  };
  var runApp = function (env) {
      var runGenLibDeps = function (v) {
          return function (result) {
              return Control_Bind.bind(Effect_Aff.bindAff)(Node_FS_Aff.exists(v.libraryDepFile))(function (fileExists) {
                  var $51 = fileExists && !env.force;
                  if ($51) {
                      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                          Effect_Console.log("Error: Output file '" + (v.libraryDepFile + "'already exists. To overwrite this file, use the `--force` flag."))();
                          return Effect_Console.log("Exiting program.")();
                      });
                  };
                  return Control_Bind.bind(Effect_Aff.bindAff)(Node_FS_Aff.readTextFile(Node_Encoding.UTF8.value)(v.finishedDepsFile))(function (finishedDeps) {
                      var depsToRemove = Data_Functor.map(Data_Functor.functorArray)(Data_String_Common.trim)(Data_String_Common.split("\x0a")(finishedDeps));
                      var removedDeps = removeFinishedDeps(depsToRemove)(result);
                      var allDepsKnown = findAllTransitiveDeps(removedDeps);
                      var orderedContent = mkOrderedContent(mkSortedPackageArray(allDepsKnown));
                      return Node_FS_Aff.writeTextFile(Node_Encoding.UTF8.value)(v.libraryDepFile)(orderedContent);
                  });
              });
          };
      };
      return Control_Bind.bind(Effect_Aff.bindAff)(Node_FS_Aff.readTextFile(Node_Encoding.UTF8.value)(env.input))(function (packageJson) {
          var decode = function (j) {
              return Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Data_Argonaut_Decode_Error.printJsonDecodeError)(Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeForeignObject(Data_Argonaut_Decode_Class.decodeJsonJson))(j))(function (v) {
                  return Control_Bind.bind(Data_Either.bindEither)(Data_TraversableWithIndex.forWithIndex(Data_Either.applicativeEither)(Foreign_Object.traversableWithIndexObject)(v)(function (key) {
                      return function (val) {
                          return Control_Bind.bind(Data_Either.bindEither)(Data_Argonaut_Decode_Class.decodeJson(Data_Argonaut_Decode_Class.decodeRecord(Data_Argonaut_Decode_Class.gDecodeJsonCons(Data_Argonaut_Decode_Class.decodeFieldId(Data_Argonaut_Decode_Class.decodeArray(Data_Argonaut_Decode_Class.decodeJsonString)))(Data_Argonaut_Decode_Class.gDecodeJsonCons(Data_Argonaut_Decode_Class.decodeFieldId(Data_Argonaut_Decode_Class.decodeJsonString))(Data_Argonaut_Decode_Class.gDecodeJsonCons(Data_Argonaut_Decode_Class.decodeFieldId(Data_Argonaut_Decode_Class.decodeJsonString))(Data_Argonaut_Decode_Class.gDecodeJsonNil)({
                              reflectSymbol: function () {
                                  return "version";
                              }
                          })()())({
                              reflectSymbol: function () {
                                  return "repo";
                              }
                          })()())({
                              reflectSymbol: function () {
                                  return "dependencies";
                              }
                          })()())())(val))(function (v1) {
                              return Control_Applicative.pure(Data_Either.applicativeEither)(new Data_Tuple.Tuple(key, v1));
                          });
                      };
                  }))(function (keyVals) {
                      return Control_Applicative.pure(Data_Either.applicativeEither)(Data_Map_Internal.fromFoldable(Data_Ord.ordString)(Foreign_Object.foldableObject)(keyVals));
                  });
              }));
          };
          var v = Control_Bind.bindFlipped(Data_Either.bindEither)(decode)(Data_Argonaut_Parser.jsonParser(packageJson));
          if (v instanceof Data_Either.Left) {
              return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                  Effect_Console.log("Decoding error while parsing JSON file")();
                  return Effect_Console.log(v.value0)();
              });
          };
          if (v instanceof Data_Either.Right) {
              if (env.command instanceof CLI.GenLibraryDeps) {
                  return runGenLibDeps(env.command.value0)(v.value0);
              };
              if (env.command instanceof CLI.GenSpagoFiles) {
                  return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit);
              };
              throw new Error("Failed pattern match at Application (line 48, column 7 - line 52, column 20): " + [ env.command.constructor.name ]);
          };
          throw new Error("Failed pattern match at Application (line 43, column 3 - line 52, column 20): " + [ v.constructor.name ]);
      });
  };
  exports["runApp"] = runApp;
})(PS);
(function(exports) {
  "use strict";

  exports.process = process;

  exports.exit = function (code) {
    return function () {
      process.exit(code);
    };
  };

  exports.copyArray = function (xs) {
    return function () {
      return xs.slice();
    };
  };
})(PS["Node.Process"] = PS["Node.Process"] || {});
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Node.Process"] = $PS["Node.Process"] || {};
  var exports = $PS["Node.Process"];
  var $foreign = $PS["Node.Process"];
  var argv = $foreign.copyArray($foreign.process.argv);
  exports["argv"] = argv;
  exports["exit"] = $foreign.exit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.7
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var Application = $PS["Application"];
  var ArgParse_Basic = $PS["ArgParse.Basic"];
  var CLI = $PS["CLI"];
  var Data_Array = $PS["Data.Array"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Console = $PS["Effect.Console"];
  var Node_Process = $PS["Node.Process"];                
  var main = function __do() {
      var args = Data_Functor.map(Effect.functorEffect)(Data_Array.drop(2))(Node_Process.argv)();
      var v = CLI.parseCliArgs(args);
      if (v instanceof Data_Either.Left) {
          Effect_Console.log(ArgParse_Basic.printArgError(v.value0))();
          if (v.value0.value1 instanceof ArgParse_Basic.ShowHelp) {
              return Node_Process.exit(0)();
          };
          if (v.value0.value1 instanceof ArgParse_Basic.ShowInfo) {
              return Node_Process.exit(0)();
          };
          return Node_Process.exit(1)();
      };
      if (v instanceof Data_Either.Right) {
          return Effect_Aff.launchAff_(Application.runApp(v.value0))();
      };
      throw new Error("Failed pattern match at Main (line 18, column 3 - line 29, column 30): " + [ v.constructor.name ]);
  };
  exports["main"] = main;
})(PS);
PS["Main"].main();